========== UNITY SCRIPT DUMP ==========
Time : 2025-10-11T17:52:16
Root : Scripts
Ext  : .cs
=======================================

# ==== FILE 1/32: Scripts\Chicken\ChickenDefinitionSO.cs
# SIZE: 1135 bytes | LINES: 31
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenDefinitionSO.cs
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Chicken Definition")]
public class ChickenDefinitionSO : ScriptableObject
{
    [Header("Meta")]
    public string id = "chicken_soldier";
    public ChickenType type = ChickenType.Soldier;

    [Header("Stats (per unit)")]
    public long baseDamage = 10;         // sát thương/viên
    public float rateOfFire = 2.0f;      // viên/giây
    [Range(0, 1f)] public float critChance = 0.1f;
    public float critMultiplier = 2.0f;
    public float range = 8f;

    [Header("Targeting")]
    public bool prioritizeClosest = true;  // ưu tiên gần nhất
    public bool allowThroughWalls = true;  // nếu false sẽ raycast line-of-sight

    [Header("Firing Mode")]
    public Projectile projectilePrefab;     // nếu để trống => Instant Hit
    public float projectileSpeed = 16f;
    public bool areaOfEffect = false;
    public float aoeRadius = 1.5f;
    [Header("Shop")]
    public long basePrice = 100; // chỉnh theo loại gà
    [Header("Visuals")]
    public Sprite icon;
}
# ---- END ----

# ==== FILE 2/32: Scripts\Chicken\ChickenType.cs
# SIZE: 341 bytes | LINES: 12
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenType.cs
using UnityEngine;

public enum ChickenType
{
    Soldier,   // Pistol – cơ bản, rẻ
    Rapid,     // SMG – tốc độ cao
    Sniper,    // chậm, crit lớn
    Shotgun,   // rải gần
    Rocket,    // AoE
    Support    // buff (để trống damage, sau gắn sau)
}
# ---- END ----

# ==== FILE 3/32: Scripts\Chicken\ChickenUnit.cs
# SIZE: 6965 bytes | LINES: 198
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenUnit.cs
using System;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(Transform))]
public class ChickenUnit : MonoBehaviour
{
    [Header("Bind")]
    public ChickenDefinitionSO def;

    [Header("Scan")]
    public LayerMask enemyLayer;      // set Layer "Enemy" nếu có
    public bool usePhysicsScan = true;
    public float scanInterval = 0.2f; // thời gian giữa mỗi lần tìm target

    float _cooldown;
    float _scanTimer;
    Enemy _currentTarget;

    // ===== Multiplier helpers (null-safe) =====
    float TeamDamageMul() => UpgradeManager.I ? UpgradeManager.I.TeamDamageMul() : 1f;
    float TeamASMul() => UpgradeManager.I ? UpgradeManager.I.TeamASMul() : 1f;
    float PerTypeMul() => (UpgradeManager.I && def) ? UpgradeManager.I.PerTypeMul(def.type) : 1f;

    float EffectiveCooldown()
    {
        if (def == null) return 9999f;
        float rofEff = Mathf.Max(0.01f, def.rateOfFire * TeamASMul());
        return 1f / rofEff;
    }

    long DamagePerShot(float critMul)
    {
        if (def == null) return 0;
        double dmg = (double)def.baseDamage * TeamDamageMul() * PerTypeMul() * critMul;
        if (dmg < 0d) dmg = 0d;
        if (dmg > long.MaxValue) dmg = long.MaxValue;
        return (long)Math.Round(dmg);
    }

    float RollCritMul()
    {
        if (def == null || def.critChance <= 0f || def.critMultiplier <= 1f) return 1f;
        return (UnityEngine.Random.value < def.critChance) ? def.critMultiplier : 1f;
    }

    // DPS lý thuyết = dmg * (1 + critChance*(critMul-1)) * ROF * multipliers
    public float TheoreticalDPS
    {
        get
        {
            if (def == null) return 0f;
            double avgCritMul = 1.0 + (double)def.critChance * ((double)def.critMultiplier - 1.0);
            double perShot = (double)def.baseDamage * TeamDamageMul() * PerTypeMul() * avgCritMul;
            double dps = perShot * (double)(def.rateOfFire * TeamASMul());
            return (float)dps;
        }
    }

    void Update()
    {
        if (def == null) return;

        // Tìm target định kỳ
        _scanTimer -= Time.deltaTime;
        if (_scanTimer <= 0f)
        {
            _scanTimer = scanInterval;
            AcquireTarget();
        }

        // Mất mục tiêu nếu ra khỏi tầm/không active
        if (_currentTarget != null)
        {
            float dist = Vector3.Distance(transform.position, _currentTarget.transform.position);
            if (dist > def.range || !_currentTarget.gameObject.activeInHierarchy)
            {
                _currentTarget = null;
            }
        }

        // Bắn
        _cooldown -= Time.deltaTime;
        if (_currentTarget != null && _cooldown <= 0f)
        {
            FireAt(_currentTarget);
            _cooldown = EffectiveCooldown(); // đã nhân Team AS
        }
    }

    void AcquireTarget()
    {
        Vector3 center = transform.position;

        if (usePhysicsScan && enemyLayer.value != 0)
        {
            // quét tròn bằng Physics2D
            var hits = Physics2D.OverlapCircleAll(center, def.range, enemyLayer);
            Enemy best = null;
            float bestScore = float.PositiveInfinity; // khoảng cách làm score

            foreach (var h in hits)
            {
                Enemy e = h.GetComponent<Enemy>();
                if (e == null || !e.gameObject.activeInHierarchy) continue;

                float d = Vector3.SqrMagnitude(e.transform.position - center);
                if (def.prioritizeClosest)
                {
                    if (d < bestScore) { best = e; bestScore = d; }
                }
                else
                {
                    // TODO: có thể đổi sang tiêu chí "gần Base nhất" sau
                    if (d < bestScore) { best = e; bestScore = d; }
                }
            }
            _currentTarget = best;
            return;
        }

        // fallback: tìm mọi Enemy (ít tối ưu nhưng đủ dùng bản proto)
        Enemy[] all = GameObject.FindObjectsByType<Enemy>(FindObjectsInactive.Exclude, FindObjectsSortMode.None);
        Enemy best2 = null;
        float bs = float.PositiveInfinity;
        foreach (var e in all)
        {
            if (!e.gameObject.activeInHierarchy) continue;
            float d = Vector3.Distance(center, e.transform.position);
            if (d <= def.range && d < bs)
            {
                bs = d; best2 = e;
            }
        }
        _currentTarget = best2;
    }

    void FireAt(Enemy target)
    {
        if (target == null) return;

        float critMul = RollCritMul();
        long damage = DamagePerShot(critMul); // đã nhân Team/PerType

        // Nếu có projectile prefab => bắn đạn
        if (def.projectilePrefab != null)
        {
            var proj = Instantiate(def.projectilePrefab, transform.position, Quaternion.identity);
            proj.damage = damage;
            proj.speed = def.projectileSpeed;
            proj.target = target.transform;

            // Truyền thông tin AoE & mask (để xử lý khi va chạm)
            proj.areaOfEffect = def.areaOfEffect;
            proj.aoeRadius = def.aoeRadius;
            proj.enemyLayer = enemyLayer;
        }
        else
        {
            // Instant hit (raycast optional)
            if (!def.allowThroughWalls)
            {
                Vector2 dir = (target.transform.position - transform.position).normalized;
                float dist = Vector3.Distance(transform.position, target.transform.position);
                // Nếu có Layer tường riêng bạn thêm mask chặn vào đây
                Physics2D.Raycast(transform.position, dir, dist);
            }
            target.TakeDamage(damage);

            // AoE instant
            if (def.areaOfEffect && def.aoeRadius > 0.01f)
            {
                var hits = Physics2D.OverlapCircleAll(target.transform.position, def.aoeRadius, enemyLayer);
                foreach (var h in hits)
                {
                    var e = h.GetComponent<Enemy>();
                    if (e != null && e != target) e.TakeDamage(damage);
                }
            }
        }
    }

#if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        if (def == null) return;
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, def.range);
        if (def.areaOfEffect)
        {
            Gizmos.color = new Color(1f, 0.5f, 0.1f, 0.8f);
            // vẽ minh hoạ AOE ngay cạnh gà (chỉ là gizmo tham khảo)
            Gizmos.DrawWireSphere(transform.position + Vector3.right * 0.5f, Mathf.Max(0.1f, def.aoeRadius));
        }
    }
#endif
}
# ---- END ----

# ==== FILE 4/32: Scripts\Chicken\EquipSlots.cs
# SIZE: 4132 bytes | LINES: 138
# ---- BEGIN ----
// Assets/Scripts/Chicken/EquipSlots.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class EquipSlots : MonoBehaviour
{
    [Serializable]
    public class Slot
    {
        public Transform mountPoint;    // nơi đặt prefab gà (empty child)
        public ChickenUnit current;     // instance runtime
    }

    [Serializable]
    public struct PrefabMap
    {
        public ChickenType type;        // Soldier/Rapid/Sniper/Shotgun/Rocket/Support
        public ChickenUnit prefab;      // prefab riêng cho loại đó (nếu có)
    }

    [Header("Slots (5)")]
    public Slot[] slots = new Slot[5];

    [Header("Prefab mặc định (fallback)")]
    public ChickenUnit chickenPrefab;

    [Header("Prefab theo loại (tuỳ chọn)")]
    public PrefabMap[] typePrefabs;     // map type -> prefab riêng (ưu tiên dùng)

    public int SlotCount => slots?.Length ?? 0;
    public bool IsValidIndex(int index) => index >= 0 && index < SlotCount;

    // Sự kiện UI có thể nghe để cập nhật icon/hud
    public event Action OnRosterChanged;
    public event Action<int, ChickenUnit> OnAssigned;
    public event Action<int> OnRemoved;

    // ========== Public helpers ==========
    public bool IsEmpty(int index) => IsValidIndex(index) && slots[index].current == null;

    public bool HasEmpty()
    {
        for (int i = 0; i < SlotCount; i++) if (IsEmpty(i)) return true;
        return false;
    }

    public int FirstEmptyIndex()
    {
        for (int i = 0; i < SlotCount; i++) if (IsEmpty(i)) return i;
        return -1;
    }

    public ChickenUnit AssignFirstEmpty(ChickenDefinitionSO def)
    {
        int idx = FirstEmptyIndex();
        return idx >= 0 ? Assign(idx, def) : null;
    }

    // ========== Core ==========

    public ChickenUnit Assign(int slotIndex, ChickenDefinitionSO def)
    {
        if (!IsValidIndex(slotIndex) || def == null) return null;

        var prefab = GetPrefabFor(def);
        if (prefab == null)
        {
            Debug.LogWarning("[EquipSlots] Missing prefab for " + def.name);
            return null;
        }

        // Clear slot cũ (nếu có)
        Remove(slotIndex);

        // Spawn mới
        var s = slots[slotIndex];
        var parent = s.mountPoint != null ? s.mountPoint : transform;

        var inst = Instantiate(prefab, parent);
        inst.transform.localPosition = Vector3.zero;
        inst.transform.localRotation = Quaternion.identity;
        inst.transform.localScale = Vector3.one;

        inst.def = def;  // 👈 bind loại gà (stat/behaviour lấy từ def)
        s.current = inst;

        OnAssigned?.Invoke(slotIndex, inst);
        OnRosterChanged?.Invoke();
        return inst;
    }

    public void Remove(int slotIndex)
    {
        if (!IsValidIndex(slotIndex)) return;
        var s = slots[slotIndex];
        if (s.current != null)
        {
            Destroy(s.current.gameObject); // TODO: đổi sang pool nếu cần
            s.current = null;
            OnRemoved?.Invoke(slotIndex);
            OnRosterChanged?.Invoke();
        }
    }

    public void ClearAll()
    {
        for (int i = 0; i < SlotCount; i++) Remove(i);
    }

    public float GetTeamDPS()
    {
        float dps = 0f;
        for (int i = 0; i < SlotCount; i++)
        {
            var c = slots[i].current;
            if (c != null && c.def != null) dps += c.TheoreticalDPS;
        }
        return dps;
    }

    // ========== Internal ==========

    ChickenUnit GetPrefabFor(ChickenDefinitionSO def)
    {
        // Ưu tiên prefab theo loại (nếu map)
        if (typePrefabs != null)
        {
            for (int i = 0; i < typePrefabs.Length; i++)
            {
                if (typePrefabs[i].prefab != null && typePrefabs[i].type == def.type)
                    return typePrefabs[i].prefab;
            }
        }
        // Fallback về prefab mặc định
        return chickenPrefab;
    }
}
# ---- END ----

# ==== FILE 5/32: Scripts\Chicken\TeamAutoAssign.cs
# SIZE: 344 bytes | LINES: 16
# ---- BEGIN ----
using UnityEngine;

public class TeamAutoAssign : MonoBehaviour
{
    public EquipSlots team;
    public ChickenDefinitionSO soldier;

    void Start()
    {
        if (!team) team = GetComponent<EquipSlots>();
        if (team && soldier)
        {
            team.Assign(0, soldier); // gán 1 gà vào Slot0
        }
    }
}
# ---- END ----

# ==== FILE 6/32: Scripts\Combat\BaseHealth.cs
# SIZE: 731 bytes | LINES: 28
# ---- BEGIN ----
using System;
using UnityEngine;

public class BaseHealth : MonoBehaviour
{
    [Header("Config")]
    public long baseHp = 500;
    public long hpPerWave = 40; // gợi ý công thức: 500 + wave×40

    [Header("Runtime (read only)")]
    [SerializeField] private long currentHp;
    public event Action OnBaseDead;

    void Start()
    {
        var wave = Mathf.Max(0, SaveManager.Data.waveIndex);
        currentHp = baseHp + hpPerWave * wave;
    }

    public long CurrentHp => currentHp;

    public void TakeDamage(long dmg)
    {
        if (currentHp <= 0) return;
        currentHp = Math.Max(0, currentHp - Math.Max(0, dmg));
        if (currentHp == 0) OnBaseDead?.Invoke();
    }
}
# ---- END ----

# ==== FILE 7/32: Scripts\Combat\Enemy\Enemy.cs
# SIZE: 1505 bytes | LINES: 52
# ---- BEGIN ----
// Enemy.cs
using UnityEngine;

[RequireComponent(typeof(Collider2D))]
public class Enemy : MonoBehaviour
{
    public EnemyDefinitionSO def;
    public BaseHealth targetBase;
    public float laneY = 0f;
    public float spawnX = 10f;

    private long hp;
    private bool _dead;        // ✅ chốt chống double-die

    void OnEnable()
    {
        _dead = false;         // ✅ reset mỗi lần spawn lại
        hp = def != null ? def.baseHP : 10;
        var pos = transform.position;
        transform.position = new Vector3(spawnX, laneY, pos.z);
    }

    void Update()
    {
        if (_dead) return;     // ✅ đã chết thì thôi
        transform.position += Vector3.left * (def != null ? def.moveSpeed : 1.5f) * Time.deltaTime;
    }

    public void TakeDamage(long dmg)
    {
        if (_dead) return;     // ✅ guard
        hp -= Mathf.Max(0, (int)dmg);
        if (hp <= 0) Die();
    }

    void OnTriggerEnter2D(Collider2D c)
    {
        if (_dead) return;     // ✅ guard
        var b = c.GetComponent<BaseHealth>();
        if (!b) return;
        b.TakeDamage(def != null ? def.touchDamage : 10);
        Die();                 // có thể trùng với kết liễu bằng đạn nếu không có guard
    }

    void Die()
    {
        if (_dead) return;     // ✅ guard
        _dead = true;
        EconomyManager.I.AddCoin(def != null ? def.bounty : 1);
        gameObject.SetActive(false);
    }
}
# ---- END ----

# ==== FILE 8/32: Scripts\Combat\Enemy\EnemyDefinitionSO.cs
# SIZE: 410 bytes | LINES: 12
# ---- BEGIN ----
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Enemy Definition")]
public class EnemyDefinitionSO : ScriptableObject
{
    public string id = "zombie_basic";
    public long baseHP = 30;
    public float moveSpeed = 1.5f;
    public long touchDamage = 10;   // sát thương vào Base khi chạm
    public long bounty = 5;         // coin rơi khi chết
    public bool isBoss = false;
}
# ---- END ----

# ==== FILE 9/32: Scripts\Combat\Projectile.cs
# SIZE: 2211 bytes | LINES: 84
# ---- BEGIN ----
// Assets/Scripts/Combat/Projectile.cs
using UnityEngine;

/// <summary>
/// Đạn homing đơn giản:
/// - Set: damage, speed, target (Transform)
/// - Tự bay về target; khi chạm thì gây sát thương (và AoE nếu bật).
/// - Có maxLifetime để tránh "mồ côi".
/// </summary>
public class Projectile : MonoBehaviour
{
    [Header("Flight")]
    public float speed = 10f;
    public float maxLifetime = 5f;

    [Header("Payload")]
    public long damage;
    public Transform target;

    [Header("AoE on hit")]
    public bool areaOfEffect = false;
    public float aoeRadius = 0f;
    public LayerMask enemyLayer;

    bool _launched;

    void OnEnable()
    {
        _launched = true;
        CancelInvoke();
        Invoke(nameof(Despawn), maxLifetime);
    }

    void Update()
    {
        if (!_launched) return;

        if (target == null || !target.gameObject.activeInHierarchy)
        {
            Despawn();
            return;
        }

        Vector3 to = target.position - transform.position;
        float dist = to.magnitude;
        float step = speed * Time.deltaTime;

        if (dist <= step || dist < 0.01f)
        {
            // On-hit
            var enemy = target.GetComponent<Enemy>();
            if (enemy != null) enemy.TakeDamage(damage);

            if (areaOfEffect && aoeRadius > 0.01f)
            {
                var hits = Physics2D.OverlapCircleAll(target.position, aoeRadius, enemyLayer);
                foreach (var h in hits)
                {
                    var e = h.GetComponent<Enemy>();
                    if (e && (!enemy || e != enemy)) e.TakeDamage(damage);
                }
            }

            Despawn();
            return;
        }

        Vector3 dir = to / dist;
        transform.position += dir * step;
        if (dir.sqrMagnitude > 0.0001f) transform.right = dir; // quay đầu đạn
    }

    void OnDisable()
    {
        CancelInvoke();
        _launched = false;
    }

    void Despawn()
    {
        _launched = false;
        Destroy(gameObject); // TODO: đổi sang Object Pool nếu cần
    }
}
# ---- END ----

# ==== FILE 10/32: Scripts\Core\Economy\EconomyManager.cs
# SIZE: 883 bytes | LINES: 35
# ---- BEGIN ----
using System;
using UnityEngine;

public class EconomyManager : MonoBehaviour
{
    public static EconomyManager I { get; private set; }
    public event Action<long> OnCoinChanged;

    private void Awake()
    {
        if (I != null && I != this) { Destroy(gameObject); return; }
        I = this;
        DontDestroyOnLoad(gameObject);
    }

    public long Coin => SaveManager.Data.coin;

    public void AddCoin(long v)
    {
        if (v <= 0) return;
        SaveManager.Data.coin += v;
        OnCoinChanged?.Invoke(Coin);
        SaveManager.MarkDirtyAndSave();
    }

    public bool TrySpend(long v)
    {
        if (v <= 0) return true;
        if (SaveManager.Data.coin < v) return false;
        SaveManager.Data.coin -= v;
        OnCoinChanged?.Invoke(Coin);
        SaveManager.MarkDirtyAndSave();
        return true;
    }
}
# ---- END ----

# ==== FILE 11/32: Scripts\Core\Save\SaveData.cs
# SIZE: 598 bytes | LINES: 24
# ---- BEGIN ----
using System;
using System.Collections.Generic;

[Serializable]
public class SaveData
{
    public long coin = 0;
    public int waveIndex = 0;
    public long lastOnlineUtcTicks = DateTime.UtcNow.Ticks;

    // Flags / options
    public bool autoStart = false;

    // Upgrades
    public Dictionary<string, int> teamUpgrades = new();
    public Dictionary<string, int> typeUpgrades = new();

    // Slots
    public int equipSlots = 5;
    public int prepareSlots = 12;

    // Anti-tamper
    public string hash = ""; // lưu SHA256 cho các trường quan trọng
}
# ---- END ----

# ==== FILE 12/32: Scripts\Core\Save\SaveManager.cs
# SIZE: 3281 bytes | LINES: 98
# ---- BEGIN ----
using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;
using UnityEngine;

public static class SaveManager
{
    private const string FileName = "save.json";
    private const string Salt = "CR_IDLE_DEFENSE_v1_SALT"; // đổi khi phát hành
    private static SaveData _cache;

    public static SaveData Data => _cache ??= Load();

    static string FullPath => Path.Combine(Application.persistentDataPath, FileName);

    public static SaveData Load()
    {
        try
        {
            if (!File.Exists(FullPath))
            {
                var fresh = new SaveData();
                fresh.hash = ComputeHash(fresh);
                return fresh;
            }

            var json = File.ReadAllText(FullPath);
            var data = JsonUtility.FromJson<SaveData>(json);
            if (data == null) return Fresh();

            // Verify hash (chỉ kiểm các trường kinh tế/tiến trình)
            var expected = ComputeHash(data);
            if (!string.Equals(expected, data.hash, StringComparison.Ordinal))
            {
                Debug.LogWarning("[SaveManager] Hash mismatch! Possible tamper. Resetting sensitive fields.");
                // Phòng thủ mềm: giữ cấu trúc, reset trường nhạy cảm
                data.coin = Math.Max(0, data.coin);
                data.waveIndex = Math.Max(0, data.waveIndex);
                data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
                data.teamUpgrades ??= new();
                data.typeUpgrades ??= new();
                data.hash = ComputeHash(data);
            }
            return data;
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] Load error: {e.Message}");
            return Fresh();
        }
    }

    public static void Save()
    {
        try
        {
            if (_cache == null) _cache = Fresh();
            _cache.hash = ComputeHash(_cache);
            var json = JsonUtility.ToJson(_cache, prettyPrint: true);
            File.WriteAllText(FullPath, json, Encoding.UTF8);
#if UNITY_EDITOR
            Debug.Log($"[SaveManager] Saved → {FullPath}");
#endif
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] Save error: {e.Message}");
        }
    }

    public static void MarkDirtyAndSave() => Save();

    public static void WipeAndRecreate()
    {
        try { if (File.Exists(FullPath)) File.Delete(FullPath); } catch { }
        _cache = Fresh();
        Save();
    }

    private static SaveData Fresh()
    {
        var s = new SaveData();
        s.hash = ComputeHash(s);
        return s;
    }

    private static string ComputeHash(SaveData d)
    {
        // Gộp các trường quan trọng để hash
        var payload = $"{Salt}|coin:{d.coin}|wave:{d.waveIndex}|ticks:{d.lastOnlineUtcTicks}|eq:{d.equipSlots}|prep:{d.prepareSlots}";
        using var sha = SHA256.Create();
        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(payload));
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes) sb.Append(b.ToString("x2"));
        return sb.ToString();
    }
}
# ---- END ----

# ==== FILE 13/32: Scripts\Core\Utils\DebugHotkeys.cs
# SIZE: 442 bytes | LINES: 15
# ---- BEGIN ----
#if UNITY_EDITOR
using UnityEngine;

public class DebugHotkeys : MonoBehaviour
{
    public long step = 10;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Equals)) EconomyManager.I.AddCoin(step);   // phím '=' hoặc '+'
        if (Input.GetKeyDown(KeyCode.Minus)) EconomyManager.I.TrySpend(step);  // phím '-'
        if (Input.GetKeyDown(KeyCode.Backspace)) SaveManager.WipeAndRecreate();
    }
}
#endif
# ---- END ----

# ==== FILE 14/32: Scripts\Core\Utils\ObjectPool.cs
# SIZE: 642 bytes | LINES: 28
# ---- BEGIN ----
using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T> where T : Component
{
    private readonly T prefab;
    private readonly Transform root;
    private readonly Stack<T> stack = new();

    public ObjectPool(T prefab, Transform root = null)
    {
        this.prefab = prefab;
        this.root = root;
    }

    public T Get()
    {
        T x = stack.Count > 0 ? stack.Pop() : Object.Instantiate(prefab, root);
        x.gameObject.SetActive(true);
        return x;
    }

    public void Release(T x)
    {
        x.gameObject.SetActive(false);
        stack.Push(x);
    }
}
# ---- END ----

# ==== FILE 15/32: Scripts\Core\Utils\SaveBootstrapper.cs
# SIZE: 646 bytes | LINES: 27
# ---- BEGIN ----
using System;
using UnityEngine;

public class SaveBootstrapper : MonoBehaviour
{
    private void Awake()
    {
        // Chạm SaveManager.Data để kích hoạt Load() lần đầu
        _ = SaveManager.Data;
        DontDestroyOnLoad(gameObject);
    }

    private void OnApplicationPause(bool pause)
    {
        if (pause)
        {
            SaveManager.Data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
            SaveManager.Save();
        }
    }

    private void OnApplicationQuit()
    {
        SaveManager.Data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
        SaveManager.Save();
    }
}
# ---- END ----

# ==== FILE 16/32: Scripts\Data\Progress\ProgressionCurveSO.cs
# SIZE: 700 bytes | LINES: 16
# ---- BEGIN ----
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Data/ProgressionCurve")]
public class ProgressionCurveSO : ScriptableObject
{
    [Header("Zombie / Economy growth")]
    public float hpLinear = 0.12f;      // HP tăng 12% mỗi wave
    public float bountyLinear = 0.05f;  // Coin drop tăng 5% mỗi wave
    public float waveRewardGrowth = 1.18f; // Mốc thưởng theo hàm mũ

    [Header("Session")]
    public float targetDuration = 25f;  // Thời gian mục tiêu 1 wave (giúp generator cân chỉnh số enemy)
    public float offlineFactor = 0.65f; // Hệ số thưởng offline
    public int offlineCapHours = 8;     // Giới hạn tính thưởng offline
}

# ---- END ----

# ==== FILE 17/32: Scripts\Shop\ShopManager.cs
# SIZE: 2117 bytes | LINES: 64
# ---- BEGIN ----
using System;
using UnityEngine;

public class ShopManager : MonoBehaviour
{
    public static ShopManager I { get; private set; }
    void Awake() { if (I && I != this) { Destroy(gameObject); return; } I = this; DontDestroyOnLoad(gameObject); }

    [Header("Refs")]
    public EquipSlots equipSlots;   // 5 slot có sẵn
    public UpgradeManager upgrades; // để đọc discount

    public event Action<ChickenDefinitionSO> OnChickenPurchased;

    const string KEY_BOUGHT = "__stat_total_chicken_bought";

    int TotalBought()
    {
        var dict = SaveManager.Data.teamUpgrades; // tái dùng map có sẵn
        return dict != null && dict.TryGetValue(KEY_BOUGHT, out var v) ? v : 0;
    }
    void IncBought()
    {
        var dict = SaveManager.Data.teamUpgrades;
        if (!dict.ContainsKey(KEY_BOUGHT)) dict[KEY_BOUGHT] = 0;
        dict[KEY_BOUGHT] += 1;
        SaveManager.MarkDirtyAndSave();
    }

    public long GetChickenPrice(ChickenDefinitionSO def)
    {
        if (!def) return long.MaxValue;
        int total = TotalBought();
        double price = Math.Max(1, def.basePrice) * Math.Pow(1.15, total);
        float disc = Mathf.Min(0.5f, upgrades?.TeamDiscountFrac() ?? 0f); // cap 50%
        price *= (1.0 - disc);
        return (long)Math.Round(price);
    }

    public bool TryBuyChicken(ChickenDefinitionSO def)
    {
        long price = GetChickenPrice(def);
        if (!EconomyManager.I.TrySpend(price)) return false;

        IncBought();

        // ưu tiên gán vào EquipSlots còn trống
        if (equipSlots)
        {
            for (int i = 0; i < equipSlots.SlotCount; i++)
            {
                if (equipSlots.slots[i].current == null)
                {
                    equipSlots.Assign(i, def);
                    OnChickenPurchased?.Invoke(def);
                    return true;
                }
            }
        }
        // Nếu Equip full: phát sự kiện để Prepare/Inventory nhận
        OnChickenPurchased?.Invoke(def);
        return true;
    }
}
# ---- END ----

# ==== FILE 18/32: Scripts\UI\BaseHPBinder.cs
# SIZE: 282 bytes | LINES: 14
# ---- BEGIN ----
using TMPro;
using UnityEngine;

public class BaseHPBinder : MonoBehaviour
{
    public BaseHealth baseHealth;
    public TMP_Text hpText;

    void Update()
    {
        if (baseHealth && hpText)
            hpText.text = $"Base HP: {baseHealth.CurrentHp}";
    }
}
# ---- END ----

# ==== FILE 19/32: Scripts\UI\ChickenShopPanel.cs
# SIZE: 3999 bytes | LINES: 117
# ---- BEGIN ----
// Assets/Scripts/UI/ChickenShopPanel.cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChickenShopPanel : MonoBehaviour
{
    [Header("Refs")]
    public ShopManager shop;                 // drag từ scene (_Systems)
    public UpgradeManager upgrades;          // drag từ scene (_Systems)

    [Header("Chicken Catalog")]
    public ChickenDefinitionSO[] chickens;   // danh sách gà bán

    [Header("UI Bindings (1-1 với chickens)")]
    public Button[] buyButtons;              // mỗi con gà 1 nút Buy
    public TMP_Text[] priceTexts;            // label giá
    public TMP_Text[] nameTexts;             // label tên (optional)
    public TMP_Text[] dpsTexts;              // DPS lý thuyết (optional)

    [Header("Refresh")]
    public float uiRefreshInterval = 0.25f;  // tối ưu thay vì Update mỗi frame
    float _t;

    void Awake()
    {
        // Wire click
        for (int i = 0; i < chickens.Length; i++)
        {
            int idx = i;
            if (buyButtons != null && idx < buyButtons.Length && buyButtons[idx] != null)
                buyButtons[idx].onClick.AddListener(() => OnBuy(idx));
        }

        // Nếu EconomyManager có OnCoinChanged thì lắng nghe để refresh tức thì
        TrySubscribeCoinEvent();
    }

    void OnEnable()
    {
        RefreshAll();
    }

    void Update()
    {
        _t += Time.deltaTime;
        if (_t >= uiRefreshInterval)
        {
            _t = 0f;
            RefreshAll();
        }
    }

    void OnDestroy()
    {
        TryUnsubscribeCoinEvent();
    }

    void OnBuy(int idx)
    {
        if (idx < 0 || idx >= chickens.Length) return;
        if (shop != null && chickens[idx] != null)
        {
            bool ok = shop.TryBuyChicken(chickens[idx]);
            if (ok) RefreshAll();
        }
    }

    void RefreshAll()
    {
        if (shop == null || chickens == null) return;

        for (int i = 0; i < chickens.Length; i++)
        {
            var c = chickens[i];
            if (!c) continue;

            long price = shop.GetChickenPrice(c);

            if (priceTexts != null && i < priceTexts.Length && priceTexts[i] != null)
                priceTexts[i].text = price.ToString();

            if (nameTexts != null && i < nameTexts.Length && nameTexts[i] != null)
                nameTexts[i].text = string.IsNullOrEmpty(c.name) ? $"Chicken {i + 1}" : c.name;

            if (dpsTexts != null && i < dpsTexts.Length && dpsTexts[i] != null)
            {
                // DPS preview: dùng công thức giống ChickenUnit
                double avgCritMul = 1.0 + (double)c.critChance * ((double)c.critMultiplier - 1.0);
                float dmgMul = (UpgradeManager.I ? UpgradeManager.I.TeamDamageMul() : 1f)
                              * (UpgradeManager.I ? UpgradeManager.I.PerTypeMul(c.type) : 1f);
                float asMul = (UpgradeManager.I ? UpgradeManager.I.TeamASMul() : 1f);
                double perShot = (double)c.baseDamage * dmgMul * avgCritMul;
                double dps = perShot * (double)(c.rateOfFire * asMul);
                dpsTexts[i].text = Mathf.RoundToInt((float)dps).ToString();
            }

            // enable/disable nút theo coin
            if (buyButtons != null && i < buyButtons.Length && buyButtons[i] != null)
            {
                bool canAfford = EconomyManager.I ? (EconomyManager.I.Coin >= price) : true;
                buyButtons[i].interactable = canAfford;
            }
        }
    }

    void TrySubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged += _ => RefreshAll();
    }
    void TryUnsubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged -= _ => RefreshAll(); // không hại nếu không trùng delegate
    }
}
# ---- END ----

# ==== FILE 20/32: Scripts\UI\HUDCoinBinder.cs
# SIZE: 659 bytes | LINES: 28
# ---- BEGIN ----
using TMPro;
using UnityEngine;

public class HUDCoinBinder : MonoBehaviour
{
    [SerializeField] private TMP_Text coinText;

    private void Start()
    {
        if (coinText == null)
            coinText = GetComponentInChildren<TMP_Text>();

        // init from save
        coinText.text = $"Coin: {EconomyManager.I.Coin}";
        EconomyManager.I.OnCoinChanged += OnCoinChanged;
    }

    private void OnDestroy()
    {
        if (EconomyManager.I != null)
            EconomyManager.I.OnCoinChanged -= OnCoinChanged;
    }

    private void OnCoinChanged(long value)
    {
        coinText.text = $"{value}" ;
    }
}
# ---- END ----

# ==== FILE 21/32: Scripts\UI\ResultPanelController.cs
# SIZE: 3714 bytes | LINES: 122
# ---- BEGIN ----
// Assets/Scripts/UI/ResultPanelController.cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ResultPanelController : MonoBehaviour
{
    [Header("Refs")]
    public WaveManager wm;   // nếu để trống, sẽ auto-find
    public GameObject root;

    [Header("Texts")]
    public TMP_Text title;      // "WAVE 10 CLEARED!" hoặc "FAIL!"
    public TMP_Text killText;   // "76"
    public TMP_Text earnText;   // "20,000k"
    public TMP_Text waveText;   // "Wave 10"

    [Header("Buttons")]
    public Button claimBtn;     // Claim 1x
    public Button claim2xBtn;   // Claim 2x (optional)
    public Button retryBtn;     // Retry khi fail

    void Awake()
    {
        if (wm == null) wm = FindFirstObjectByType<WaveManager>();
        if (root) root.SetActive(false);

        if (claimBtn)
        {
            claimBtn.onClick.RemoveAllListeners();
            claimBtn.onClick.AddListener(() => OnClaim(1f));
        }
        if (claim2xBtn)
        {
            claim2xBtn.onClick.RemoveAllListeners();
            claim2xBtn.onClick.AddListener(() => OnClaim(2f));
        }
        if (retryBtn)
        {
            retryBtn.onClick.RemoveAllListeners();
            retryBtn.onClick.AddListener(OnRetry);
        }
        Debug.Log($"ResultPanel: Awake (wm={(wm ? "OK" : "null")})");
    }

    void OnEnable()
    {
        if (wm == null) wm = FindFirstObjectByType<WaveManager>();
        if (wm != null)
        {
            wm.OnWin += ShowWin;
            wm.OnFail += ShowFail;
            Debug.Log("ResultPanel: Subscribed OnWin/OnFail");
        }
        else
        {
            Debug.LogWarning("ResultPanel: WaveManager not found; cannot subscribe events.");
        }
    }

    void OnDisable()
    {
        if (wm != null)
        {
            wm.OnWin -= ShowWin;
            wm.OnFail -= ShowFail;
            Debug.Log("ResultPanel: Unsubscribed OnWin/OnFail");
        }
    }

    void ShowWin()
    {
        if (!root) return;
        root.SetActive(true);

        if (title) title.text = $"WAVE {wm.ResultWaveIndex} CLEARED!";
        if (waveText) waveText.text = $"Wave {wm.ResultWaveIndex}";
        if (killText) killText.text = $"{wm.ResultTotalKill}";
        if (earnText) earnText.text = $"{wm.ResultWaveReward:N0}";

        if (claimBtn) claimBtn.gameObject.SetActive(true);
        if (claim2xBtn) claim2xBtn?.gameObject.SetActive(true);
        if (retryBtn) retryBtn.gameObject.SetActive(false);

        if (claimBtn) claimBtn.interactable = wm.CanClaim;
        if (claim2xBtn) claim2xBtn.interactable = wm.CanClaim;

        Debug.Log("ResultPanel: ShowWin → panel enabled");
    }

    void ShowFail()
    {
        if (!root) return;
        root.SetActive(true);

        if (title) title.text = "FAIL!";
        if (waveText) waveText.text = $"Failed at Wave {wm.CurrentWave}";
        if (killText) killText.text = "-";
        if (earnText) earnText.text = "0";

        if (claimBtn) claimBtn.gameObject.SetActive(false);
        if (claim2xBtn) claim2xBtn?.gameObject.SetActive(false);
        if (retryBtn) retryBtn.gameObject.SetActive(true);
        if (retryBtn) retryBtn.interactable = true;

        Debug.Log("ResultPanel: ShowFail → panel enabled");
    }

    void OnClaim(float multiplier)
    {
        wm.ClaimAndContinue(multiplier);
        if (root) root.SetActive(false);
        Debug.Log($"ResultPanel: Claim x{multiplier}");
    }

    void OnRetry()
    {
        wm.Retry();
        if (root) root.SetActive(false);
        Debug.Log("ResultPanel: Retry");
    }
}
# ---- END ----

# ==== FILE 22/32: Scripts\UI\StartMenuController.cs
# SIZE: 529 bytes | LINES: 26
# ---- BEGIN ----
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.SceneManagement;

public class StartMenuController : MonoBehaviour
{
    public AudioMixer audioMixer;

    public void OnStartClick()
    {
        SceneManager.LoadScene("Game");
    }

    public void OnExitClick()
    {
#if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
#endif
        Application.Quit();
    }

    public void SetVolume(float volume)
    {
        audioMixer.SetFloat("Volume", volume);
    }
}
# ---- END ----

# ==== FILE 23/32: Scripts\UI\UpgradeShopPanel.cs
# SIZE: 4918 bytes | LINES: 150
# ---- BEGIN ----
// Assets/Scripts/UI/UpgradeShopPanel.cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UpgradeShopPanel : MonoBehaviour
{
    [Header("Refs")]
    public UpgradeManager upgrades;  // drag từ scene (_Systems)

    [Header("Team Upgrades")]
    public string[] teamIds = {
        UpgradeIds.Team_Damage,
        UpgradeIds.Team_AS,
        UpgradeIds.Team_EggSpeed,
        UpgradeIds.Team_MPS,
        UpgradeIds.Team_Discount
    };
    public Button[] teamButtons;
    public TMP_Text[] teamPriceTexts;
    public TMP_Text[] teamLevelTexts;
    public TMP_Text[] teamNameTexts; // optional đẹp UI

    [Header("Per-Type Upgrades")]
    public ChickenType[] perTypes = {
        ChickenType.Soldier, ChickenType.Rapid, ChickenType.Sniper,
        ChickenType.Shotgun, ChickenType.Rocket, ChickenType.Support
    };
    public Button[] typeButtons;
    public TMP_Text[] typePriceTexts;
    public TMP_Text[] typeLevelTexts;
    public TMP_Text[] typeNameTexts; // optional

    [Header("Refresh")]
    public float uiRefreshInterval = 0.25f;
    float _t;

    void Awake()
    {
        // Wire team
        for (int i = 0; i < teamIds.Length; i++)
        {
            int idx = i;
            if (teamButtons != null && idx < teamButtons.Length && teamButtons[idx] != null)
                teamButtons[idx].onClick.AddListener(() => OnBuyTeam(teamIds[idx]));
        }

        // Wire per-type
        for (int i = 0; i < perTypes.Length; i++)
        {
            int idx = i;
            if (typeButtons != null && idx < typeButtons.Length && typeButtons[idx] != null)
                typeButtons[idx].onClick.AddListener(() => OnBuyType(perTypes[idx]));
        }

        TrySubscribeCoinEvent();
    }

    void OnEnable() { RefreshAll(); }
    void OnDestroy() { TryUnsubscribeCoinEvent(); }

    void Update()
    {
        _t += Time.deltaTime;
        if (_t >= uiRefreshInterval)
        {
            _t = 0f;
            RefreshAll();
        }
    }

    void OnBuyTeam(string id)
    {
        if (upgrades != null && !string.IsNullOrEmpty(id))
        {
            bool ok = upgrades.TryBuy(id);
            if (ok) RefreshAll();
        }
    }

    void OnBuyType(ChickenType t)
    {
        if (upgrades == null) return;
        bool ok = upgrades.TryBuy(UpgradeIds.TypeKey(t));
        if (ok) RefreshAll();
    }

    void RefreshAll()
    {
        if (upgrades == null) return;

        // TEAM
        for (int i = 0; i < teamIds.Length; i++)
        {
            string id = teamIds[i];
            long price = upgrades.GetPriceNext(id);
            int lv = upgrades.GetLevel(id);

            if (teamPriceTexts != null && i < teamPriceTexts.Length && teamPriceTexts[i] != null)
                teamPriceTexts[i].text = price.ToString();

            if (teamLevelTexts != null && i < teamLevelTexts.Length && teamLevelTexts[i] != null)
                teamLevelTexts[i].text = $"Lv {lv}";

            if (teamNameTexts != null && i < teamNameTexts.Length && teamNameTexts[i] != null)
                teamNameTexts[i].text = id.Replace('_', ' ').ToUpperInvariant();

            // enable/disable theo coin
            if (teamButtons != null && i < teamButtons.Length && teamButtons[i] != null)
            {
                bool canAfford = EconomyManager.I ? (EconomyManager.I.Coin >= price) : true;
                teamButtons[i].interactable = canAfford;
            }
        }

        // PER-TYPE
        for (int i = 0; i < perTypes.Length; i++)
        {
            string id = UpgradeIds.TypeKey(perTypes[i]);
            long price = upgrades.GetPriceNext(id);
            int lv = upgrades.GetLevel(id);

            if (typePriceTexts != null && i < typePriceTexts.Length && typePriceTexts[i] != null)
                typePriceTexts[i].text = price.ToString();

            if (typeLevelTexts != null && i < typeLevelTexts.Length && typeLevelTexts[i] != null)
                typeLevelTexts[i].text = $"Lv {lv}";

            if (typeNameTexts != null && i < typeNameTexts.Length && typeNameTexts[i] != null)
                typeNameTexts[i].text = perTypes[i].ToString().ToUpperInvariant();

            if (typeButtons != null && i < typeButtons.Length && typeButtons[i] != null)
            {
                bool canAfford = EconomyManager.I ? (EconomyManager.I.Coin >= price) : true;
                typeButtons[i].interactable = canAfford;
            }
        }
    }

    void TrySubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged += _ => RefreshAll();
    }
    void TryUnsubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged -= _ => RefreshAll();
    }
}
# ---- END ----

# ==== FILE 24/32: Scripts\Upgrades\UpgradeDefinitionSO.cs
# SIZE: 829 bytes | LINES: 24
# ---- BEGIN ----
using UnityEngine;
public enum UpgradeKind { Team, PerType }

[CreateAssetMenu(menuName = "CR/Upgrades/Definition")]
public class UpgradeDefinitionSO : ScriptableObject
{
    [Header("Meta")]
    public string id;
    public string displayName;
    public UpgradeKind kind;
    public ChickenType typeTarget; // dùng nếu PerType

    [Header("Economy")]
    public long baseCost = 2000;
    public float growth = 1.22f; // team dmg/as 1.22; mps 1.30; per-type 1.25

    [Header("Effect per level")]
    public float teamDamagePct = 0.08f; // 8%/lv
    public float teamASPct = 0.06f; // 6%/lv
    public float eggSeconds = 0.2f;  // 0.2s/lv
    public long mpsValue = 2;     // 2 coin/s/lv
    public float discountPct = 0.03f; // 3%/lv (cap 50%)
    public float perTypeDpsPct = 0.10f; // 10%/lv
}
# ---- END ----

# ==== FILE 25/32: Scripts\Upgrades\UpgradeIds.cs
# SIZE: 524 bytes | LINES: 12
# ---- BEGIN ----
public static class UpgradeIds
{
    // Team
    public const string Team_Damage = "team_damage";       // +8%/lv
    public const string Team_AS = "team_attack_speed"; // +6%/lv
    public const string Team_EggSpeed = "team_egg_speed";    // -0.2s/lv
    public const string Team_MPS = "team_mps";          // +2 coin/s/lv
    public const string Team_Discount = "team_discount";     // -3%/lv (cap 50%)

    // Per-type
    public static string TypeKey(ChickenType t) => $"type_{t.ToString().ToLower()}";
}
# ---- END ----

# ==== FILE 26/32: Scripts\Upgrades\UpgradeManager.cs
# SIZE: 7348 bytes | LINES: 209
# ---- BEGIN ----
// Assets/Scripts/Upgrades/UpgradeManager.cs
// Sprint 4 - Upgrade core (Team + Per-Type)
// - Quản lý level, giá nâng cấp, và xuất các multiplier/effect để hệ thống khác dùng.
// - Phụ thuộc: SaveManager (Data.teamUpgrades/typeUpgrades), EconomyManager (TrySpend),
//              UpgradeDefinitionSO[], UpgradeIds, ChickenType.
//
// HƯỚNG DẪN INSPECTOR:
//   - Gắn script này lên 1 GameObject tồn tại suốt game (ví dụ _Systems).
//   - Kéo TẤT CẢ các asset UpgradeDefinitionSO vào mảng 'upgradeDefs'.
//   - Team IDs dùng: team_damage, team_attack_speed, team_egg_speed, team_mps, team_discount
//   - Per-type IDs dùng: type_soldier, type_rapid, type_sniper, type_shotgun, type_rocket, type_support
//
// API CHÍNH:
//   int   GetLevel(string id)
//   long  GetPriceNext(string id)         // baseCost * growth^level
//   bool  TryBuy(string id)               // trừ coin & tăng level
//
//   float TeamDamageMul()  // (1 + 0.08)^lv
//   float TeamASMul()      // (1 + 0.06)^lv
//   float TeamDiscountFrac() // lv*0.03 (áp cap 50% khi TÍNH GIÁ GÀ, thực hiện ở ShopManager)
//   float TeamEggSeconds() // lv*0.2s  (dùng giảm thời gian tải trứng)
//   long  TeamMPS()        // lv*2 coin/s
//   float PerTypeMul(ChickenType t) // (1+0.10)^lv theo từng loại gà
//
// GỢI Ý HOOK:
//   - Damage mỗi viên = baseDamage * TeamDamageMul() * PerTypeMul(type) * critMul
//   - ROF hiệu dụng   = baseROF * TeamASMul()
//   - Ticker MPS: mỗi giây EconomyManager.I.AddCoin(TeamMPS());

using System;
using System.Collections.Generic;
using UnityEngine;

public class UpgradeManager : MonoBehaviour
{
    public static UpgradeManager I { get; private set; }

    [Header("Database")]
    [Tooltip("Kéo tất cả UpgradeDefinitionSO (team + per-type) vào đây")]
    public UpgradeDefinitionSO[] upgradeDefs;

    // Tra cứu nhanh theo id
    private Dictionary<string, UpgradeDefinitionSO> _byId;

    // ========================================
    // Unity lifecycle
    // ========================================
    private void Awake()
    {
        if (I != null && I != this) { Destroy(gameObject); return; }
        I = this;
        DontDestroyOnLoad(gameObject);

        // Build index
        _byId = new Dictionary<string, UpgradeDefinitionSO>(StringComparer.Ordinal);
        if (upgradeDefs != null)
        {
            foreach (var d in upgradeDefs)
            {
                if (d == null || string.IsNullOrEmpty(d.id)) continue;
                _byId[d.id] = d;
            }
        }

        // Ensure save maps
        if (SaveManager.Data.teamUpgrades == null) SaveManager.Data.teamUpgrades = new Dictionary<string, int>();
        if (SaveManager.Data.typeUpgrades == null) SaveManager.Data.typeUpgrades = new Dictionary<string, int>();
    }

    // ========================================
    // Level: get/set + persist
    // ========================================
    public int GetLevel(string id)
    {
        if (string.IsNullOrEmpty(id) || !_byId.ContainsKey(id)) return 0;

        var def = _byId[id];
        if (def.kind == UpgradeKind.Team)
        {
            return SaveManager.Data.teamUpgrades.TryGetValue(id, out var lv) ? lv : 0;
        }
        else // PerType
        {
            return SaveManager.Data.typeUpgrades.TryGetValue(id, out var lv) ? lv : 0;
        }
    }

    private void SetLevel(string id, int level)
    {
        if (string.IsNullOrEmpty(id) || !_byId.ContainsKey(id)) return;

        level = Mathf.Max(0, level);
        var def = _byId[id];

        if (def.kind == UpgradeKind.Team)
        {
            SaveManager.Data.teamUpgrades[id] = level;
        }
        else
        {
            SaveManager.Data.typeUpgrades[id] = level;
        }
        Persist();
    }

    private static void Persist()
    {
        // Dùng SaveManager.Save() để tương thích mã sẵn có của bạn
        SaveManager.Save();
    }

    // ========================================
    // Giá nâng cấp & mua
    // ========================================
    public long GetPriceNext(string id)
    {
        if (string.IsNullOrEmpty(id) || !_byId.TryGetValue(id, out var def)) return long.MaxValue;

        int lv = GetLevel(id);
        double cost = def.baseCost * Math.Pow(def.growth, lv);
        if (cost < 1d) cost = 1d;
        return (long)Math.Round(cost);
    }

    public bool TryBuy(string id)
    {
        long price = GetPriceNext(id);
        if (!EconomyManager.I.TrySpend(price)) return false;

        SetLevel(id, GetLevel(id) + 1);
        return true;
    }

    // ========================================
    // Query: Team multipliers/effects
    // ========================================
    public float TeamDamageMul()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_Damage, out var d)) return 1f;
        int lv = GetLevel(d.id);
        return Mathf.Pow(1f + d.teamDamagePct, lv);
    }

    public float TeamASMul()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_AS, out var d)) return 1f;
        int lv = GetLevel(d.id);
        return Mathf.Pow(1f + d.teamASPct, lv);
    }

    /// <summary>
    /// Tổng phần trăm giảm giá (0..1). Khi tính giá gà nhớ áp CAP 50% (min với 0.5f).
    /// </summary>
    public float TeamDiscountFrac()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_Discount, out var d)) return 0f;
        int lv = GetLevel(d.id);
        float total = lv * d.discountPct; // vd 3%/lv
        return Mathf.Max(0f, total);
    }

    /// <summary>
    /// Tổng số giây giảm vào thời gian nạp trứng (Egg Load). Tuỳ nơi dùng.
    /// </summary>
    public float TeamEggSeconds()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_EggSpeed, out var d)) return 0f;
        int lv = GetLevel(d.id);
        return lv * d.eggSeconds;
    }

    /// <summary>
    /// Tổng coin/s cộng thêm.
    /// </summary>
    public long TeamMPS()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_MPS, out var d)) return 0;
        int lv = GetLevel(d.id);
        long v = lv * d.mpsValue;
        return v < 0 ? 0 : v;
    }

    // ========================================
    // Query: Per-type multiplier
    // ========================================
    public float PerTypeMul(ChickenType type)
    {
        string id = UpgradeIds.TypeKey(type);
        if (!_byId.TryGetValue(id, out var d)) return 1f;
        int lv = GetLevel(id);
        return Mathf.Pow(1f + d.perTypeDpsPct, lv);
    }

    // ========================================
    // Tiện ích (tùy chọn): kiểm tra asset/ID
    // ========================================
#if UNITY_EDITOR
    [ContextMenu("Validate Upgrade IDs in Console")]
    private void ValidateInConsole()
    {
        foreach (var kv in _byId)
        {
            var d = kv.Value;
            string extra = d.kind == UpgradeKind.PerType ? $" (PerType:{d.typeTarget})" : " (Team)";
            Debug.Log($"[UpgradeDef] id={d.id} base={d.baseCost} growth={d.growth}{extra}");
        }
    }
#endif
}
# ---- END ----

# ==== FILE 27/32: Scripts\Wave\EnemyHook.cs
# SIZE: 413 bytes | LINES: 17
# ---- BEGIN ----
// Assets/Scripts/Wave/EnemyHook.cs
using UnityEngine;

// Gắn vào prefab Enemy để WaveManager biết khi nào đã clear hết
[RequireComponent(typeof(Enemy))]
public class EnemyHook : MonoBehaviour
{
    void OnEnable()
    {
        if (EnemyRegistry.I) EnemyRegistry.I.Register();
    }

    void OnDisable()
    {
        if (EnemyRegistry.I) EnemyRegistry.I.Unregister();
    }
}
# ---- END ----

# ==== FILE 28/32: Scripts\Wave\EnemyRegistry.cs
# SIZE: 841 bytes | LINES: 37
# ---- BEGIN ----
using System;
using UnityEngine;

public class EnemyRegistry : MonoBehaviour
{
    // Singleton để WaveManager gọi nhanh
    public static EnemyRegistry I { get; private set; }

    public event Action OnAllCleared;

    private int _alive = 0;

    void Awake()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;
    }

    /// <summary>Gọi khi Enemy spawn (EnemyHook.OnEnable)</summary>
    public void Register()
    {
        _alive++;
    }

    /// <summary>Gọi khi Enemy chết hoặc bị disable (EnemyHook.OnDisable)</summary>
    public void Unregister()
    {
        _alive = Mathf.Max(0, _alive - 1);
        if (_alive == 0) OnAllCleared?.Invoke();
    }

    public int AliveCount => _alive;
}
# ---- END ----

# ==== FILE 29/32: Scripts\Wave\WaveDefinitionSO.cs
# SIZE: 1173 bytes | LINES: 37
# ---- BEGIN ----
using System;
using UnityEngine;

namespace CR.Wave
{
    public enum LaneMode { FixedY, RandomFromList, RandomRangeY }

    [CreateAssetMenu(menuName = "CR/Wave", fileName = "Wave_")]
    public class WaveDefinitionSO : ScriptableObject
    {
        public int waveIndex;
        public float targetDuration = 25f;
        public bool isBoss;

        [Serializable]
        public struct Group
        {
            public EnemyDefinitionSO enemy;
            [Min(1)] public int count;
            [Min(0.01f)] public float interval;
            [Min(0f)] public float startTime;

            [Header("Lane Y")]
            public LaneMode laneMode;       // NEW
            public float laneY;             // dùng cho FixedY
            public float[] laneList;        // dùng khi RandomFromList
            public Vector2 yRange;          // dùng khi RandomRangeY
            // Giữ spawnX cũ, KHÔNG random
            public float spawnX;

            [Header("Timing")]
            public Vector2 intervalJitterPct; // ±% jitter (tuỳ chọn)
        }

        public Group[] groups = Array.Empty<Group>();
    }
}
# ---- END ----

# ==== FILE 30/32: Scripts\Wave\WaveManager.cs
# SIZE: 8512 bytes | LINES: 254
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveManager.cs
using CR.Wave;
using System;
using UnityEngine;

public class WaveManager : MonoBehaviour
{
    [Header("Refs")]
    public BaseHealth baseHealth;
    public WaveSpawner spawner;
    public ProgressionCurveSO progression; // để tính thưởng cơ bản

    [Header("Definitions")]
    public WaveDefinitionSO[] presets; // Wave 1-20 có thể preset tay
    public bool autoStart = true;

    [Header("Runtime (read-only)")]
    [SerializeField] private WaveState state = WaveState.Prepare;
    [SerializeField] private int currentWaveIndex; // wave đang sắp chơi (1-based)
    [SerializeField] private bool lastWin;

    public event Action OnWin;
    public event Action OnFail;

    // === Chờ clear khi spawn chưa xong / hoặc registry tới muộn ===
    bool _pendingClear;
    float _pendingSince;             // dùng làm fallback timeout
    const float PendingClearTimeout = 0.75f; // fallback nếu spawner không báo xong

    // === RESULT SNAPSHOT (để panel hiển thị & claim) ===
    int _resultWaveIndex;
    int _resultTotalKill;
    long _resultWaveReward;
    bool _claimed; // chặn claim lại

    // Expose cho UI
    public WaveState State => state;
    public int CurrentWave => currentWaveIndex;     // wave sắp đánh
    public bool LastWin => lastWin;
    public int ResultWaveIndex => _resultWaveIndex;     // wave vừa clear
    public int ResultTotalKill => _resultTotalKill;
    public long ResultWaveReward => _resultWaveReward;
    public bool CanClaim => lastWin && !_claimed && _resultWaveReward > 0;

    void Awake()
    {
        // wave đã clear nằm trong Save, nên wave sắp đánh là +1
        currentWaveIndex = Mathf.Max(1, SaveManager.Data.waveIndex + 1);
        Debug.Log($"WM: Awake, CurrentWave={currentWaveIndex}");
    }

    void OnEnable()
    {
        if (baseHealth) baseHealth.OnBaseDead += HandleBaseDead;
        TrySubscribeRegistry();
    }

    void OnDisable()
    {
        if (baseHealth) baseHealth.OnBaseDead -= HandleBaseDead;
        TryUnsubscribeRegistry();
    }

    void Start()
    {
        if (autoStart || SaveManager.Data.autoStart) GoPrepare();
    }

    void Update()
    {
        // 1) EnemyRegistry có thể sinh sau → cố gắng subscribe muộn
        if (!_subscribedRegistry) TrySubscribeRegistry();

        // 2) Nếu đã clear hết sớm nhưng còn đợt spawn, chờ đến khi spawn xong rồi chốt thắng
        if (state == WaveState.Combat && _pendingClear)
        {
            bool finished = (spawner == null) || spawner.IsFinishedSpawning;
            bool noEnemy = (EnemyRegistry.I == null) || (EnemyRegistry.I.AliveCount == 0);

            // Điều kiện chuẩn: spawn xong + không còn quái
            if (finished && noEnemy)
            {
                Debug.Log("WM: Update pending → FinalizeWin (finished && noEnemy)");
                FinalizeWin();
            }
            else
            {
                // Fallback sau một khoảng trễ vẫn không có quái → chốt thắng
                if (noEnemy && (Time.time - _pendingSince) > PendingClearTimeout)
                {
                    Debug.LogWarning("WM: Fallback FinalizeWin (timeout reached)");
                    FinalizeWin();
                }
            }
        }
    }

    public void GoPrepare()
    {
        state = WaveState.Prepare;
        lastWin = false;
        _pendingClear = false;

        // clear snapshot
        _resultWaveIndex = 0;
        _resultTotalKill = 0;
        _resultWaveReward = 0;
        _claimed = false;

        Debug.Log("WM: GoPrepare");
        if (autoStart || SaveManager.Data.autoStart) StartCombat();
    }

    public void StartCombat()
    {
        if (state != WaveState.Prepare) return;
        state = WaveState.Combat;

        var def = GetWaveDefinition(currentWaveIndex);
        if (!def) Debug.LogWarning($"[WaveManager] Missing Wave {currentWaveIndex} def");
        spawner.Begin(def);

        Debug.Log("WM: StartCombat");
        // BaseHP đã tự scale trong BaseHealth theo Save.waveIndex
    }

    // === Tính thống kê cho 1 wave bất kỳ (không phụ thuộc state) ===
    public (int totalKill, long waveReward) CalcWaveStats(int waveIndex)
    {
        var def = GetWaveDefinition(waveIndex);
        if (def == null) return (0, 0);

        int totalKill = 0;
        foreach (var g in def.groups) totalKill += g.count;

        // Ví dụ công thức thưởng:
        // reward = 20_000 * (waveRewardGrowth ^ (waveIndex - 1))
        float growth = progression ? Mathf.Pow(progression.waveRewardGrowth, waveIndex - 1) : 1f;
        long baseRw = 20000;
        long reward = Mathf.RoundToInt(baseRw * growth);
        return (totalKill, reward);
    }

    WaveDefinitionSO GetWaveDefinition(int waveIndex)
    {
        if (presets != null && waveIndex - 1 < presets.Length && waveIndex - 1 >= 0)
            return presets[waveIndex - 1];

        return (presets != null && presets.Length > 0)
            ? presets[Mathf.Clamp(presets.Length - 1, 0, presets.Length - 1)]
            : null;
    }

    // ===== EnemyRegistry subscription (chắc chắn) =====
    bool _subscribedRegistry = false;

    void TrySubscribeRegistry()
    {
        if (_subscribedRegistry) return;
        if (EnemyRegistry.I == null) return;

        EnemyRegistry.I.OnAllCleared += HandleAllCleared;
        _subscribedRegistry = true;
        Debug.Log("WM: Subscribed EnemyRegistry.OnAllCleared");
    }

    void TryUnsubscribeRegistry()
    {
        if (!_subscribedRegistry) return;
        if (EnemyRegistry.I != null)
            EnemyRegistry.I.OnAllCleared -= HandleAllCleared;
        _subscribedRegistry = false;
    }

    void HandleAllCleared()
    {
        if (state != WaveState.Combat) return;

        if (spawner != null && !spawner.IsFinishedSpawning)
        {
            // Hết quái tạm thời, nhưng còn đợt spawn sau ⇒ chờ
            _pendingClear = true;
            _pendingSince = Time.time;
            Debug.Log("WM: OnAllCleared (pending until spawner finished)");
            return;
        }

        Debug.Log("WM: OnAllCleared → FinalizeWin immediately");
        FinalizeWin();
    }

    void FinalizeWin()
    {
        // WIN → chốt snapshot (không cộng coin, không advance ở đây)
        lastWin = true;
        _resultWaveIndex = currentWaveIndex;
        (_resultTotalKill, _resultWaveReward) = CalcWaveStats(currentWaveIndex);
        _claimed = false;

        state = WaveState.Result;
        _pendingClear = false;

        Debug.Log($"WM: FinalizeWin → wave={_resultWaveIndex}, kill={_resultTotalKill}, reward={_resultWaveReward}");
        OnWin?.Invoke(); // UI bật panel
    }

    void HandleBaseDead()
    {
        if (state != WaveState.Combat) return;

        lastWin = false;
        _resultWaveIndex = 0;
        _resultTotalKill = 0;
        _resultWaveReward = 0;
        _claimed = true; // chặn claim

        state = WaveState.Result;
        _pendingClear = false;

        Debug.Log("WM: HandleBaseDead → FAIL");
        OnFail?.Invoke();
    }

    // Claim thưởng và chuyển sang Prepare. multiplier = 1 (Claim), = 2 (Claim 2x)...
    public void ClaimAndContinue(float multiplier = 1f)
    {
        if (state != WaveState.Result) return;

        if (lastWin && !_claimed && _resultWaveReward > 0)
        {
            long reward = Mathf.RoundToInt(_resultWaveReward * Mathf.Max(1f, multiplier));
            EconomyManager.I.AddCoin(reward);

            // Advance wave sau khi đã claim
            SaveManager.Data.waveIndex = Mathf.Max(SaveManager.Data.waveIndex, _resultWaveIndex);
            SaveManager.MarkDirtyAndSave();
            currentWaveIndex = SaveManager.Data.waveIndex + 1;

            _claimed = true;
            Debug.Log($"WM: Claim reward={reward}, advance to {currentWaveIndex}");
        }

        GoPrepare();
    }

    public void Retry()
    {
        if (state != WaveState.Result) return;
        // Không advance, không cộng coin
        state = WaveState.Prepare;
        Debug.Log("WM: Retry");
        StartCombat();
    }
}
# ---- END ----

# ==== FILE 31/32: Scripts\Wave\WaveSpawner.cs
# SIZE: 4064 bytes | LINES: 132
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveSpawner.cs
using CR.Wave;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class EnemyPrefabEntry
{
    public EnemyDefinitionSO definition;   // SO của loại enemy
    public Enemy prefab;                   // Prefab tương ứng
}

public class WaveSpawner : MonoBehaviour
{
    [Header("Mapping SO → Prefab")]
    public EnemyPrefabEntry[] enemyPrefabs;   // Kéo thả trong Inspector

    [Header("Refs")]
    public Transform poolRoot;                // Container tùy chọn
    public BaseHealth baseHealth;             // Base để quái tìm đến

    [Header("Runtime")]
    public WaveDefinitionSO wave;

    // Nội bộ
    Dictionary<EnemyDefinitionSO, ObjectPool<Enemy>> _pools;
    Dictionary<EnemyDefinitionSO, Enemy> _prefabByDef;
    float _t;
    int[] _spawnedPerGroup;
    bool _active;

    void Awake()
    {
        _pools = new Dictionary<EnemyDefinitionSO, ObjectPool<Enemy>>();
        _prefabByDef = new Dictionary<EnemyDefinitionSO, Enemy>();

        if (enemyPrefabs == null) return;

        foreach (var entry in enemyPrefabs)
        {
            // ✅ dùng so sánh null, KHÔNG dùng !
            if (entry == null || entry.definition == null || entry.prefab == null)
                continue;

            _prefabByDef[entry.definition] = entry.prefab;
            _pools[entry.definition] = new ObjectPool<Enemy>(entry.prefab, poolRoot);
        }
    }

    public void Begin(WaveDefinitionSO def)
    {
        wave = def;
        _t = 0f;
        _active = true;
        _spawnedPerGroup = wave != null && wave.groups != null ? new int[wave.groups.Length] : null;
    }

    public bool IsFinishedSpawning
    {
        get
        {
            if (wave == null || _spawnedPerGroup == null) return true;
            for (int i = 0; i < _spawnedPerGroup.Length; i++)
                if (_spawnedPerGroup[i] < wave.groups[i].count) return false;
            return true;
        }
    }

    void Update()
    {
        if (!_active || wave == null) return;
        _t += Time.deltaTime;

        for (int i = 0; i < wave.groups.Length; i++)
        {
            var g = wave.groups[i];
            if (_t < g.startTime) continue;

            if (_spawnedPerGroup[i] < g.count)
            {
                int expect = Mathf.FloorToInt((_t - g.startTime) / Mathf.Max(0.01f, g.interval)) + 1;
                int toSpawn = Mathf.Clamp(expect - _spawnedPerGroup[i], 0, g.count - _spawnedPerGroup[i]);
                for (int k = 0; k < toSpawn; k++) SpawnOne(g);
                _spawnedPerGroup[i] += toSpawn;
            }
        }

        if (IsFinishedSpawning) _active = false;
    }

    private void SpawnOne(WaveDefinitionSO.Group g)
    {
        if (!_pools.TryGetValue(g.enemy, out var pool))
        {
            Debug.LogError($"[WaveSpawner] Missing prefab mapping for {g.enemy?.name}");
            return;
        }

        var e = pool.Get();
        e.def = g.enemy;
        e.targetBase = baseHealth;

        float y;
        switch (g.laneMode)
        {
            case LaneMode.RandomFromList:
                var list = g.laneList != null && g.laneList.Length > 0
                           ? g.laneList
                           : new[] { g.laneY };
                y = list[Random.Range(0, list.Length)];
                break;

            case LaneMode.RandomRangeY:
                var yr = g.yRange;
                if (yr.x > yr.y) (yr.x, yr.y) = (yr.y, yr.x);
                y = Random.Range(yr.x, yr.y);
                break;

            default: // FixedY
                y = g.laneY;
                break;
        }

        // Giữ X cố định (spawnX của group)
        float x = g.spawnX;

        e.transform.position = new Vector3(x, y, 0f);

        if (!e.TryGetComponent<EnemyHook>(out _))
            e.gameObject.AddComponent<EnemyHook>();
    }
}
# ---- END ----

# ==== FILE 32/32: Scripts\Wave\WaveState.cs
# SIZE: 108 bytes | LINES: 7
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveState.cs
public enum WaveState
{
    Prepare,
    Combat,
    Result
}
# ---- END ----

========== SUMMARY ==========
32 file(s), 2064 lines, 64996 bytes
