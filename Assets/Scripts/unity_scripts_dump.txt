========== UNITY SCRIPT DUMP ==========
Time : 2025-09-30T01:35:22
Root : Scripts
Ext  : .cs
=======================================

# ==== FILE 1/31: Scripts\Chicken\ChickenDefinitionSO.cs
# SIZE: 1135 bytes | LINES: 31
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenDefinitionSO.cs
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Chicken Definition")]
public class ChickenDefinitionSO : ScriptableObject
{
    [Header("Meta")]
    public string id = "chicken_soldier";
    public ChickenType type = ChickenType.Soldier;

    [Header("Stats (per unit)")]
    public long baseDamage = 10;         // s√°t th∆∞∆°ng/vi√™n
    public float rateOfFire = 2.0f;      // vi√™n/gi√¢y
    [Range(0, 1f)] public float critChance = 0.1f;
    public float critMultiplier = 2.0f;
    public float range = 8f;

    [Header("Targeting")]
    public bool prioritizeClosest = true;  // ∆∞u ti√™n g·∫ßn nh·∫•t
    public bool allowThroughWalls = true;  // n·∫øu false s·∫Ω raycast line-of-sight

    [Header("Firing Mode")]
    public Projectile projectilePrefab;     // n·∫øu ƒë·ªÉ tr·ªëng => Instant Hit
    public float projectileSpeed = 16f;
    public bool areaOfEffect = false;
    public float aoeRadius = 1.5f;
    [Header("Shop")]
    public long basePrice = 100; // ch·ªânh theo lo·∫°i g√†
    [Header("Visuals")]
    public Sprite icon;
}
# ---- END ----

# ==== FILE 2/31: Scripts\Chicken\ChickenType.cs
# SIZE: 341 bytes | LINES: 12
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenType.cs
using UnityEngine;

public enum ChickenType
{
    Soldier,   // Pistol ‚Äì c∆° b·∫£n, r·∫ª
    Rapid,     // SMG ‚Äì t·ªëc ƒë·ªô cao
    Sniper,    // ch·∫≠m, crit l·ªõn
    Shotgun,   // r·∫£i g·∫ßn
    Rocket,    // AoE
    Support    // buff (ƒë·ªÉ tr·ªëng damage, sau g·∫Øn sau)
}
# ---- END ----

# ==== FILE 3/31: Scripts\Chicken\ChickenUnit.cs
# SIZE: 6965 bytes | LINES: 198
# ---- BEGIN ----
// Assets/Scripts/Chicken/ChickenUnit.cs
using System;
using System.Collections.Generic;
using UnityEngine;

[RequireComponent(typeof(Transform))]
public class ChickenUnit : MonoBehaviour
{
    [Header("Bind")]
    public ChickenDefinitionSO def;

    [Header("Scan")]
    public LayerMask enemyLayer;      // set Layer "Enemy" n·∫øu c√≥
    public bool usePhysicsScan = true;
    public float scanInterval = 0.2f; // th·ªùi gian gi·ªØa m·ªói l·∫ßn t√¨m target

    float _cooldown;
    float _scanTimer;
    Enemy _currentTarget;

    // ===== Multiplier helpers (null-safe) =====
    float TeamDamageMul() => UpgradeManager.I ? UpgradeManager.I.TeamDamageMul() : 1f;
    float TeamASMul() => UpgradeManager.I ? UpgradeManager.I.TeamASMul() : 1f;
    float PerTypeMul() => (UpgradeManager.I && def) ? UpgradeManager.I.PerTypeMul(def.type) : 1f;

    float EffectiveCooldown()
    {
        if (def == null) return 9999f;
        float rofEff = Mathf.Max(0.01f, def.rateOfFire * TeamASMul());
        return 1f / rofEff;
    }

    long DamagePerShot(float critMul)
    {
        if (def == null) return 0;
        double dmg = (double)def.baseDamage * TeamDamageMul() * PerTypeMul() * critMul;
        if (dmg < 0d) dmg = 0d;
        if (dmg > long.MaxValue) dmg = long.MaxValue;
        return (long)Math.Round(dmg);
    }

    float RollCritMul()
    {
        if (def == null || def.critChance <= 0f || def.critMultiplier <= 1f) return 1f;
        return (UnityEngine.Random.value < def.critChance) ? def.critMultiplier : 1f;
    }

    // DPS l√Ω thuy·∫øt = dmg * (1 + critChance*(critMul-1)) * ROF * multipliers
    public float TheoreticalDPS
    {
        get
        {
            if (def == null) return 0f;
            double avgCritMul = 1.0 + (double)def.critChance * ((double)def.critMultiplier - 1.0);
            double perShot = (double)def.baseDamage * TeamDamageMul() * PerTypeMul() * avgCritMul;
            double dps = perShot * (double)(def.rateOfFire * TeamASMul());
            return (float)dps;
        }
    }

    void Update()
    {
        if (def == null) return;

        // T√¨m target ƒë·ªãnh k·ª≥
        _scanTimer -= Time.deltaTime;
        if (_scanTimer <= 0f)
        {
            _scanTimer = scanInterval;
            AcquireTarget();
        }

        // M·∫•t m·ª•c ti√™u n·∫øu ra kh·ªèi t·∫ßm/kh√¥ng active
        if (_currentTarget != null)
        {
            float dist = Vector3.Distance(transform.position, _currentTarget.transform.position);
            if (dist > def.range || !_currentTarget.gameObject.activeInHierarchy)
            {
                _currentTarget = null;
            }
        }

        // B·∫Øn
        _cooldown -= Time.deltaTime;
        if (_currentTarget != null && _cooldown <= 0f)
        {
            FireAt(_currentTarget);
            _cooldown = EffectiveCooldown(); // ƒë√£ nh√¢n Team AS
        }
    }

    void AcquireTarget()
    {
        Vector3 center = transform.position;

        if (usePhysicsScan && enemyLayer.value != 0)
        {
            // qu√©t tr√≤n b·∫±ng Physics2D
            var hits = Physics2D.OverlapCircleAll(center, def.range, enemyLayer);
            Enemy best = null;
            float bestScore = float.PositiveInfinity; // kho·∫£ng c√°ch l√†m score

            foreach (var h in hits)
            {
                Enemy e = h.GetComponent<Enemy>();
                if (e == null || !e.gameObject.activeInHierarchy) continue;

                float d = Vector3.SqrMagnitude(e.transform.position - center);
                if (def.prioritizeClosest)
                {
                    if (d < bestScore) { best = e; bestScore = d; }
                }
                else
                {
                    // TODO: c√≥ th·ªÉ ƒë·ªïi sang ti√™u ch√≠ "g·∫ßn Base nh·∫•t" sau
                    if (d < bestScore) { best = e; bestScore = d; }
                }
            }
            _currentTarget = best;
            return;
        }

        // fallback: t√¨m m·ªçi Enemy (√≠t t·ªëi ∆∞u nh∆∞ng ƒë·ªß d√πng b·∫£n proto)
        Enemy[] all = GameObject.FindObjectsByType<Enemy>(FindObjectsInactive.Exclude, FindObjectsSortMode.None);
        Enemy best2 = null;
        float bs = float.PositiveInfinity;
        foreach (var e in all)
        {
            if (!e.gameObject.activeInHierarchy) continue;
            float d = Vector3.Distance(center, e.transform.position);
            if (d <= def.range && d < bs)
            {
                bs = d; best2 = e;
            }
        }
        _currentTarget = best2;
    }

    void FireAt(Enemy target)
    {
        if (target == null) return;

        float critMul = RollCritMul();
        long damage = DamagePerShot(critMul); // ƒë√£ nh√¢n Team/PerType

        // N·∫øu c√≥ projectile prefab => b·∫Øn ƒë·∫°n
        if (def.projectilePrefab != null)
        {
            var proj = Instantiate(def.projectilePrefab, transform.position, Quaternion.identity);
            proj.damage = damage;
            proj.speed = def.projectileSpeed;
            proj.target = target.transform;

            // Truy·ªÅn th√¥ng tin AoE & mask (ƒë·ªÉ x·ª≠ l√Ω khi va ch·∫°m)
            proj.areaOfEffect = def.areaOfEffect;
            proj.aoeRadius = def.aoeRadius;
            proj.enemyLayer = enemyLayer;
        }
        else
        {
            // Instant hit (raycast optional)
            if (!def.allowThroughWalls)
            {
                Vector2 dir = (target.transform.position - transform.position).normalized;
                float dist = Vector3.Distance(transform.position, target.transform.position);
                // N·∫øu c√≥ Layer t∆∞·ªùng ri√™ng b·∫°n th√™m mask ch·∫∑n v√†o ƒë√¢y
                Physics2D.Raycast(transform.position, dir, dist);
            }
            target.TakeDamage(damage);

            // AoE instant
            if (def.areaOfEffect && def.aoeRadius > 0.01f)
            {
                var hits = Physics2D.OverlapCircleAll(target.transform.position, def.aoeRadius, enemyLayer);
                foreach (var h in hits)
                {
                    var e = h.GetComponent<Enemy>();
                    if (e != null && e != target) e.TakeDamage(damage);
                }
            }
        }
    }

#if UNITY_EDITOR
    void OnDrawGizmosSelected()
    {
        if (def == null) return;
        Gizmos.color = Color.cyan;
        Gizmos.DrawWireSphere(transform.position, def.range);
        if (def.areaOfEffect)
        {
            Gizmos.color = new Color(1f, 0.5f, 0.1f, 0.8f);
            // v·∫Ω minh ho·∫° AOE ngay c·∫°nh g√† (ch·ªâ l√† gizmo tham kh·∫£o)
            Gizmos.DrawWireSphere(transform.position + Vector3.right * 0.5f, Mathf.Max(0.1f, def.aoeRadius));
        }
    }
#endif
}
# ---- END ----

# ==== FILE 4/31: Scripts\Chicken\EquipSlots.cs
# SIZE: 4132 bytes | LINES: 138
# ---- BEGIN ----
// Assets/Scripts/Chicken/EquipSlots.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class EquipSlots : MonoBehaviour
{
    [Serializable]
    public class Slot
    {
        public Transform mountPoint;    // n∆°i ƒë·∫∑t prefab g√† (empty child)
        public ChickenUnit current;     // instance runtime
    }

    [Serializable]
    public struct PrefabMap
    {
        public ChickenType type;        // Soldier/Rapid/Sniper/Shotgun/Rocket/Support
        public ChickenUnit prefab;      // prefab ri√™ng cho lo·∫°i ƒë√≥ (n·∫øu c√≥)
    }

    [Header("Slots (5)")]
    public Slot[] slots = new Slot[5];

    [Header("Prefab m·∫∑c ƒë·ªãnh (fallback)")]
    public ChickenUnit chickenPrefab;

    [Header("Prefab theo lo·∫°i (tu·ª≥ ch·ªçn)")]
    public PrefabMap[] typePrefabs;     // map type -> prefab ri√™ng (∆∞u ti√™n d√πng)

    public int SlotCount => slots?.Length ?? 0;
    public bool IsValidIndex(int index) => index >= 0 && index < SlotCount;

    // S·ª± ki·ªán UI c√≥ th·ªÉ nghe ƒë·ªÉ c·∫≠p nh·∫≠t icon/hud
    public event Action OnRosterChanged;
    public event Action<int, ChickenUnit> OnAssigned;
    public event Action<int> OnRemoved;

    // ========== Public helpers ==========
    public bool IsEmpty(int index) => IsValidIndex(index) && slots[index].current == null;

    public bool HasEmpty()
    {
        for (int i = 0; i < SlotCount; i++) if (IsEmpty(i)) return true;
        return false;
    }

    public int FirstEmptyIndex()
    {
        for (int i = 0; i < SlotCount; i++) if (IsEmpty(i)) return i;
        return -1;
    }

    public ChickenUnit AssignFirstEmpty(ChickenDefinitionSO def)
    {
        int idx = FirstEmptyIndex();
        return idx >= 0 ? Assign(idx, def) : null;
    }

    // ========== Core ==========

    public ChickenUnit Assign(int slotIndex, ChickenDefinitionSO def)
    {
        if (!IsValidIndex(slotIndex) || def == null) return null;

        var prefab = GetPrefabFor(def);
        if (prefab == null)
        {
            Debug.LogWarning("[EquipSlots] Missing prefab for " + def.name);
            return null;
        }

        // Clear slot c≈© (n·∫øu c√≥)
        Remove(slotIndex);

        // Spawn m·ªõi
        var s = slots[slotIndex];
        var parent = s.mountPoint != null ? s.mountPoint : transform;

        var inst = Instantiate(prefab, parent);
        inst.transform.localPosition = Vector3.zero;
        inst.transform.localRotation = Quaternion.identity;
        inst.transform.localScale = Vector3.one;

        inst.def = def;  // üëà bind lo·∫°i g√† (stat/behaviour l·∫•y t·ª´ def)
        s.current = inst;

        OnAssigned?.Invoke(slotIndex, inst);
        OnRosterChanged?.Invoke();
        return inst;
    }

    public void Remove(int slotIndex)
    {
        if (!IsValidIndex(slotIndex)) return;
        var s = slots[slotIndex];
        if (s.current != null)
        {
            Destroy(s.current.gameObject); // TODO: ƒë·ªïi sang pool n·∫øu c·∫ßn
            s.current = null;
            OnRemoved?.Invoke(slotIndex);
            OnRosterChanged?.Invoke();
        }
    }

    public void ClearAll()
    {
        for (int i = 0; i < SlotCount; i++) Remove(i);
    }

    public float GetTeamDPS()
    {
        float dps = 0f;
        for (int i = 0; i < SlotCount; i++)
        {
            var c = slots[i].current;
            if (c != null && c.def != null) dps += c.TheoreticalDPS;
        }
        return dps;
    }

    // ========== Internal ==========

    ChickenUnit GetPrefabFor(ChickenDefinitionSO def)
    {
        // ∆Øu ti√™n prefab theo lo·∫°i (n·∫øu map)
        if (typePrefabs != null)
        {
            for (int i = 0; i < typePrefabs.Length; i++)
            {
                if (typePrefabs[i].prefab != null && typePrefabs[i].type == def.type)
                    return typePrefabs[i].prefab;
            }
        }
        // Fallback v·ªÅ prefab m·∫∑c ƒë·ªãnh
        return chickenPrefab;
    }
}
# ---- END ----

# ==== FILE 5/31: Scripts\Chicken\TeamAutoAssign.cs
# SIZE: 344 bytes | LINES: 16
# ---- BEGIN ----
using UnityEngine;

public class TeamAutoAssign : MonoBehaviour
{
    public EquipSlots team;
    public ChickenDefinitionSO soldier;

    void Start()
    {
        if (!team) team = GetComponent<EquipSlots>();
        if (team && soldier)
        {
            team.Assign(0, soldier); // g√°n 1 g√† v√†o Slot0
        }
    }
}
# ---- END ----

# ==== FILE 6/31: Scripts\Combat\BaseHealth.cs
# SIZE: 731 bytes | LINES: 28
# ---- BEGIN ----
using System;
using UnityEngine;

public class BaseHealth : MonoBehaviour
{
    [Header("Config")]
    public long baseHp = 500;
    public long hpPerWave = 40; // g·ª£i √Ω c√¥ng th·ª©c: 500 + wave√ó40

    [Header("Runtime (read only)")]
    [SerializeField] private long currentHp;
    public event Action OnBaseDead;

    void Start()
    {
        var wave = Mathf.Max(0, SaveManager.Data.waveIndex);
        currentHp = baseHp + hpPerWave * wave;
    }

    public long CurrentHp => currentHp;

    public void TakeDamage(long dmg)
    {
        if (currentHp <= 0) return;
        currentHp = Math.Max(0, currentHp - Math.Max(0, dmg));
        if (currentHp == 0) OnBaseDead?.Invoke();
    }
}
# ---- END ----

# ==== FILE 7/31: Scripts\Combat\Enemy\Enemy.cs
# SIZE: 1505 bytes | LINES: 52
# ---- BEGIN ----
// Enemy.cs
using UnityEngine;

[RequireComponent(typeof(Collider2D))]
public class Enemy : MonoBehaviour
{
    public EnemyDefinitionSO def;
    public BaseHealth targetBase;
    public float laneY = 0f;
    public float spawnX = 10f;

    private long hp;
    private bool _dead;        // ‚úÖ ch·ªët ch·ªëng double-die

    void OnEnable()
    {
        _dead = false;         // ‚úÖ reset m·ªói l·∫ßn spawn l·∫°i
        hp = def != null ? def.baseHP : 10;
        var pos = transform.position;
        transform.position = new Vector3(spawnX, laneY, pos.z);
    }

    void Update()
    {
        if (_dead) return;     // ‚úÖ ƒë√£ ch·∫øt th√¨ th√¥i
        transform.position += Vector3.left * (def != null ? def.moveSpeed : 1.5f) * Time.deltaTime;
    }

    public void TakeDamage(long dmg)
    {
        if (_dead) return;     // ‚úÖ guard
        hp -= Mathf.Max(0, (int)dmg);
        if (hp <= 0) Die();
    }

    void OnTriggerEnter2D(Collider2D c)
    {
        if (_dead) return;     // ‚úÖ guard
        var b = c.GetComponent<BaseHealth>();
        if (!b) return;
        b.TakeDamage(def != null ? def.touchDamage : 10);
        Die();                 // c√≥ th·ªÉ tr√πng v·ªõi k·∫øt li·ªÖu b·∫±ng ƒë·∫°n n·∫øu kh√¥ng c√≥ guard
    }

    void Die()
    {
        if (_dead) return;     // ‚úÖ guard
        _dead = true;
        EconomyManager.I.AddCoin(def != null ? def.bounty : 1);
        gameObject.SetActive(false);
    }
}
# ---- END ----

# ==== FILE 8/31: Scripts\Combat\Enemy\EnemyDefinitionSO.cs
# SIZE: 410 bytes | LINES: 12
# ---- BEGIN ----
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Enemy Definition")]
public class EnemyDefinitionSO : ScriptableObject
{
    public string id = "zombie_basic";
    public long baseHP = 30;
    public float moveSpeed = 1.5f;
    public long touchDamage = 10;   // s√°t th∆∞∆°ng v√†o Base khi ch·∫°m
    public long bounty = 5;         // coin r∆°i khi ch·∫øt
    public bool isBoss = false;
}
# ---- END ----

# ==== FILE 9/31: Scripts\Combat\Projectile.cs
# SIZE: 2211 bytes | LINES: 84
# ---- BEGIN ----
// Assets/Scripts/Combat/Projectile.cs
using UnityEngine;

/// <summary>
/// ƒê·∫°n homing ƒë∆°n gi·∫£n:
/// - Set: damage, speed, target (Transform)
/// - T·ª± bay v·ªÅ target; khi ch·∫°m th√¨ g√¢y s√°t th∆∞∆°ng (v√† AoE n·∫øu b·∫≠t).
/// - C√≥ maxLifetime ƒë·ªÉ tr√°nh "m·ªì c√¥i".
/// </summary>
public class Projectile : MonoBehaviour
{
    [Header("Flight")]
    public float speed = 10f;
    public float maxLifetime = 5f;

    [Header("Payload")]
    public long damage;
    public Transform target;

    [Header("AoE on hit")]
    public bool areaOfEffect = false;
    public float aoeRadius = 0f;
    public LayerMask enemyLayer;

    bool _launched;

    void OnEnable()
    {
        _launched = true;
        CancelInvoke();
        Invoke(nameof(Despawn), maxLifetime);
    }

    void Update()
    {
        if (!_launched) return;

        if (target == null || !target.gameObject.activeInHierarchy)
        {
            Despawn();
            return;
        }

        Vector3 to = target.position - transform.position;
        float dist = to.magnitude;
        float step = speed * Time.deltaTime;

        if (dist <= step || dist < 0.01f)
        {
            // On-hit
            var enemy = target.GetComponent<Enemy>();
            if (enemy != null) enemy.TakeDamage(damage);

            if (areaOfEffect && aoeRadius > 0.01f)
            {
                var hits = Physics2D.OverlapCircleAll(target.position, aoeRadius, enemyLayer);
                foreach (var h in hits)
                {
                    var e = h.GetComponent<Enemy>();
                    if (e && (!enemy || e != enemy)) e.TakeDamage(damage);
                }
            }

            Despawn();
            return;
        }

        Vector3 dir = to / dist;
        transform.position += dir * step;
        if (dir.sqrMagnitude > 0.0001f) transform.right = dir; // quay ƒë·∫ßu ƒë·∫°n
    }

    void OnDisable()
    {
        CancelInvoke();
        _launched = false;
    }

    void Despawn()
    {
        _launched = false;
        Destroy(gameObject); // TODO: ƒë·ªïi sang Object Pool n·∫øu c·∫ßn
    }
}
# ---- END ----

# ==== FILE 10/31: Scripts\Core\Economy\EconomyManager.cs
# SIZE: 883 bytes | LINES: 35
# ---- BEGIN ----
using System;
using UnityEngine;

public class EconomyManager : MonoBehaviour
{
    public static EconomyManager I { get; private set; }
    public event Action<long> OnCoinChanged;

    private void Awake()
    {
        if (I != null && I != this) { Destroy(gameObject); return; }
        I = this;
        DontDestroyOnLoad(gameObject);
    }

    public long Coin => SaveManager.Data.coin;

    public void AddCoin(long v)
    {
        if (v <= 0) return;
        SaveManager.Data.coin += v;
        OnCoinChanged?.Invoke(Coin);
        SaveManager.MarkDirtyAndSave();
    }

    public bool TrySpend(long v)
    {
        if (v <= 0) return true;
        if (SaveManager.Data.coin < v) return false;
        SaveManager.Data.coin -= v;
        OnCoinChanged?.Invoke(Coin);
        SaveManager.MarkDirtyAndSave();
        return true;
    }
}
# ---- END ----

# ==== FILE 11/31: Scripts\Core\Save\SaveData.cs
# SIZE: 598 bytes | LINES: 24
# ---- BEGIN ----
using System;
using System.Collections.Generic;

[Serializable]
public class SaveData
{
    public long coin = 0;
    public int waveIndex = 0;
    public long lastOnlineUtcTicks = DateTime.UtcNow.Ticks;

    // Flags / options
    public bool autoStart = false;

    // Upgrades
    public Dictionary<string, int> teamUpgrades = new();
    public Dictionary<string, int> typeUpgrades = new();

    // Slots
    public int equipSlots = 5;
    public int prepareSlots = 12;

    // Anti-tamper
    public string hash = ""; // l∆∞u SHA256 cho c√°c tr∆∞·ªùng quan tr·ªçng
}
# ---- END ----

# ==== FILE 12/31: Scripts\Core\Save\SaveManager.cs
# SIZE: 3281 bytes | LINES: 98
# ---- BEGIN ----
using System;
using System.IO;
using System.Text;
using System.Security.Cryptography;
using UnityEngine;

public static class SaveManager
{
    private const string FileName = "save.json";
    private const string Salt = "CR_IDLE_DEFENSE_v1_SALT"; // ƒë·ªïi khi ph√°t h√†nh
    private static SaveData _cache;

    public static SaveData Data => _cache ??= Load();

    static string FullPath => Path.Combine(Application.persistentDataPath, FileName);

    public static SaveData Load()
    {
        try
        {
            if (!File.Exists(FullPath))
            {
                var fresh = new SaveData();
                fresh.hash = ComputeHash(fresh);
                return fresh;
            }

            var json = File.ReadAllText(FullPath);
            var data = JsonUtility.FromJson<SaveData>(json);
            if (data == null) return Fresh();

            // Verify hash (ch·ªâ ki·ªÉm c√°c tr∆∞·ªùng kinh t·∫ø/ti·∫øn tr√¨nh)
            var expected = ComputeHash(data);
            if (!string.Equals(expected, data.hash, StringComparison.Ordinal))
            {
                Debug.LogWarning("[SaveManager] Hash mismatch! Possible tamper. Resetting sensitive fields.");
                // Ph√≤ng th·ªß m·ªÅm: gi·ªØ c·∫•u tr√∫c, reset tr∆∞·ªùng nh·∫°y c·∫£m
                data.coin = Math.Max(0, data.coin);
                data.waveIndex = Math.Max(0, data.waveIndex);
                data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
                data.teamUpgrades ??= new();
                data.typeUpgrades ??= new();
                data.hash = ComputeHash(data);
            }
            return data;
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] Load error: {e.Message}");
            return Fresh();
        }
    }

    public static void Save()
    {
        try
        {
            if (_cache == null) _cache = Fresh();
            _cache.hash = ComputeHash(_cache);
            var json = JsonUtility.ToJson(_cache, prettyPrint: true);
            File.WriteAllText(FullPath, json, Encoding.UTF8);
#if UNITY_EDITOR
            Debug.Log($"[SaveManager] Saved ‚Üí {FullPath}");
#endif
        }
        catch (Exception e)
        {
            Debug.LogError($"[SaveManager] Save error: {e.Message}");
        }
    }

    public static void MarkDirtyAndSave() => Save();

    public static void WipeAndRecreate()
    {
        try { if (File.Exists(FullPath)) File.Delete(FullPath); } catch { }
        _cache = Fresh();
        Save();
    }

    private static SaveData Fresh()
    {
        var s = new SaveData();
        s.hash = ComputeHash(s);
        return s;
    }

    private static string ComputeHash(SaveData d)
    {
        // G·ªôp c√°c tr∆∞·ªùng quan tr·ªçng ƒë·ªÉ hash
        var payload = $"{Salt}|coin:{d.coin}|wave:{d.waveIndex}|ticks:{d.lastOnlineUtcTicks}|eq:{d.equipSlots}|prep:{d.prepareSlots}";
        using var sha = SHA256.Create();
        var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(payload));
        var sb = new StringBuilder(bytes.Length * 2);
        foreach (var b in bytes) sb.Append(b.ToString("x2"));
        return sb.ToString();
    }
}
# ---- END ----

# ==== FILE 13/31: Scripts\Core\Utils\DebugHotkeys.cs
# SIZE: 442 bytes | LINES: 15
# ---- BEGIN ----
#if UNITY_EDITOR
using UnityEngine;

public class DebugHotkeys : MonoBehaviour
{
    public long step = 10;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Equals)) EconomyManager.I.AddCoin(step);   // ph√≠m '=' ho·∫∑c '+'
        if (Input.GetKeyDown(KeyCode.Minus)) EconomyManager.I.TrySpend(step);  // ph√≠m '-'
        if (Input.GetKeyDown(KeyCode.Backspace)) SaveManager.WipeAndRecreate();
    }
}
#endif
# ---- END ----

# ==== FILE 14/31: Scripts\Core\Utils\ObjectPool.cs
# SIZE: 642 bytes | LINES: 28
# ---- BEGIN ----
using System.Collections.Generic;
using UnityEngine;

public class ObjectPool<T> where T : Component
{
    private readonly T prefab;
    private readonly Transform root;
    private readonly Stack<T> stack = new();

    public ObjectPool(T prefab, Transform root = null)
    {
        this.prefab = prefab;
        this.root = root;
    }

    public T Get()
    {
        T x = stack.Count > 0 ? stack.Pop() : Object.Instantiate(prefab, root);
        x.gameObject.SetActive(true);
        return x;
    }

    public void Release(T x)
    {
        x.gameObject.SetActive(false);
        stack.Push(x);
    }
}
# ---- END ----

# ==== FILE 15/31: Scripts\Core\Utils\SaveBootstrapper.cs
# SIZE: 646 bytes | LINES: 27
# ---- BEGIN ----
using System;
using UnityEngine;

public class SaveBootstrapper : MonoBehaviour
{
    private void Awake()
    {
        // Ch·∫°m SaveManager.Data ƒë·ªÉ k√≠ch ho·∫°t Load() l·∫ßn ƒë·∫ßu
        _ = SaveManager.Data;
        DontDestroyOnLoad(gameObject);
    }

    private void OnApplicationPause(bool pause)
    {
        if (pause)
        {
            SaveManager.Data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
            SaveManager.Save();
        }
    }

    private void OnApplicationQuit()
    {
        SaveManager.Data.lastOnlineUtcTicks = DateTime.UtcNow.Ticks;
        SaveManager.Save();
    }
}
# ---- END ----

# ==== FILE 16/31: Scripts\Data\Progress\ProgressionCurveSO.cs
# SIZE: 700 bytes | LINES: 16
# ---- BEGIN ----
using UnityEngine;

[CreateAssetMenu(menuName = "CR/Data/ProgressionCurve")]
public class ProgressionCurveSO : ScriptableObject
{
    [Header("Zombie / Economy growth")]
    public float hpLinear = 0.12f;      // HP tƒÉng 12% m·ªói wave
    public float bountyLinear = 0.05f;  // Coin drop tƒÉng 5% m·ªói wave
    public float waveRewardGrowth = 1.18f; // M·ªëc th∆∞·ªüng theo h√†m m≈©

    [Header("Session")]
    public float targetDuration = 25f;  // Th·ªùi gian m·ª•c ti√™u 1 wave (gi√∫p generator c√¢n ch·ªânh s·ªë enemy)
    public float offlineFactor = 0.65f; // H·ªá s·ªë th∆∞·ªüng offline
    public int offlineCapHours = 8;     // Gi·ªõi h·∫°n t√≠nh th∆∞·ªüng offline
}

# ---- END ----

# ==== FILE 17/31: Scripts\Shop\ShopManager.cs
# SIZE: 2117 bytes | LINES: 64
# ---- BEGIN ----
using System;
using UnityEngine;

public class ShopManager : MonoBehaviour
{
    public static ShopManager I { get; private set; }
    void Awake() { if (I && I != this) { Destroy(gameObject); return; } I = this; DontDestroyOnLoad(gameObject); }

    [Header("Refs")]
    public EquipSlots equipSlots;   // 5 slot c√≥ s·∫µn
    public UpgradeManager upgrades; // ƒë·ªÉ ƒë·ªçc discount

    public event Action<ChickenDefinitionSO> OnChickenPurchased;

    const string KEY_BOUGHT = "__stat_total_chicken_bought";

    int TotalBought()
    {
        var dict = SaveManager.Data.teamUpgrades; // t√°i d√πng map c√≥ s·∫µn
        return dict != null && dict.TryGetValue(KEY_BOUGHT, out var v) ? v : 0;
    }
    void IncBought()
    {
        var dict = SaveManager.Data.teamUpgrades;
        if (!dict.ContainsKey(KEY_BOUGHT)) dict[KEY_BOUGHT] = 0;
        dict[KEY_BOUGHT] += 1;
        SaveManager.MarkDirtyAndSave();
    }

    public long GetChickenPrice(ChickenDefinitionSO def)
    {
        if (!def) return long.MaxValue;
        int total = TotalBought();
        double price = Math.Max(1, def.basePrice) * Math.Pow(1.15, total);
        float disc = Mathf.Min(0.5f, upgrades?.TeamDiscountFrac() ?? 0f); // cap 50%
        price *= (1.0 - disc);
        return (long)Math.Round(price);
    }

    public bool TryBuyChicken(ChickenDefinitionSO def)
    {
        long price = GetChickenPrice(def);
        if (!EconomyManager.I.TrySpend(price)) return false;

        IncBought();

        // ∆∞u ti√™n g√°n v√†o EquipSlots c√≤n tr·ªëng
        if (equipSlots)
        {
            for (int i = 0; i < equipSlots.SlotCount; i++)
            {
                if (equipSlots.slots[i].current == null)
                {
                    equipSlots.Assign(i, def);
                    OnChickenPurchased?.Invoke(def);
                    return true;
                }
            }
        }
        // N·∫øu Equip full: ph√°t s·ª± ki·ªán ƒë·ªÉ Prepare/Inventory nh·∫≠n
        OnChickenPurchased?.Invoke(def);
        return true;
    }
}
# ---- END ----

# ==== FILE 18/31: Scripts\UI\BaseHPBinder.cs
# SIZE: 282 bytes | LINES: 14
# ---- BEGIN ----
using TMPro;
using UnityEngine;

public class BaseHPBinder : MonoBehaviour
{
    public BaseHealth baseHealth;
    public TMP_Text hpText;

    void Update()
    {
        if (baseHealth && hpText)
            hpText.text = $"Base HP: {baseHealth.CurrentHp}";
    }
}
# ---- END ----

# ==== FILE 19/31: Scripts\UI\ChickenShopPanel.cs
# SIZE: 3999 bytes | LINES: 117
# ---- BEGIN ----
// Assets/Scripts/UI/ChickenShopPanel.cs
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChickenShopPanel : MonoBehaviour
{
    [Header("Refs")]
    public ShopManager shop;                 // drag t·ª´ scene (_Systems)
    public UpgradeManager upgrades;          // drag t·ª´ scene (_Systems)

    [Header("Chicken Catalog")]
    public ChickenDefinitionSO[] chickens;   // danh s√°ch g√† b√°n

    [Header("UI Bindings (1-1 v·ªõi chickens)")]
    public Button[] buyButtons;              // m·ªói con g√† 1 n√∫t Buy
    public TMP_Text[] priceTexts;            // label gi√°
    public TMP_Text[] nameTexts;             // label t√™n (optional)
    public TMP_Text[] dpsTexts;              // DPS l√Ω thuy·∫øt (optional)

    [Header("Refresh")]
    public float uiRefreshInterval = 0.25f;  // t·ªëi ∆∞u thay v√¨ Update m·ªói frame
    float _t;

    void Awake()
    {
        // Wire click
        for (int i = 0; i < chickens.Length; i++)
        {
            int idx = i;
            if (buyButtons != null && idx < buyButtons.Length && buyButtons[idx] != null)
                buyButtons[idx].onClick.AddListener(() => OnBuy(idx));
        }

        // N·∫øu EconomyManager c√≥ OnCoinChanged th√¨ l·∫Øng nghe ƒë·ªÉ refresh t·ª©c th√¨
        TrySubscribeCoinEvent();
    }

    void OnEnable()
    {
        RefreshAll();
    }

    void Update()
    {
        _t += Time.deltaTime;
        if (_t >= uiRefreshInterval)
        {
            _t = 0f;
            RefreshAll();
        }
    }

    void OnDestroy()
    {
        TryUnsubscribeCoinEvent();
    }

    void OnBuy(int idx)
    {
        if (idx < 0 || idx >= chickens.Length) return;
        if (shop != null && chickens[idx] != null)
        {
            bool ok = shop.TryBuyChicken(chickens[idx]);
            if (ok) RefreshAll();
        }
    }

    void RefreshAll()
    {
        if (shop == null || chickens == null) return;

        for (int i = 0; i < chickens.Length; i++)
        {
            var c = chickens[i];
            if (!c) continue;

            long price = shop.GetChickenPrice(c);

            if (priceTexts != null && i < priceTexts.Length && priceTexts[i] != null)
                priceTexts[i].text = price.ToString();

            if (nameTexts != null && i < nameTexts.Length && nameTexts[i] != null)
                nameTexts[i].text = string.IsNullOrEmpty(c.name) ? $"Chicken {i + 1}" : c.name;

            if (dpsTexts != null && i < dpsTexts.Length && dpsTexts[i] != null)
            {
                // DPS preview: d√πng c√¥ng th·ª©c gi·ªëng ChickenUnit
                double avgCritMul = 1.0 + (double)c.critChance * ((double)c.critMultiplier - 1.0);
                float dmgMul = (UpgradeManager.I ? UpgradeManager.I.TeamDamageMul() : 1f)
                              * (UpgradeManager.I ? UpgradeManager.I.PerTypeMul(c.type) : 1f);
                float asMul = (UpgradeManager.I ? UpgradeManager.I.TeamASMul() : 1f);
                double perShot = (double)c.baseDamage * dmgMul * avgCritMul;
                double dps = perShot * (double)(c.rateOfFire * asMul);
                dpsTexts[i].text = Mathf.RoundToInt((float)dps).ToString();
            }

            // enable/disable n√∫t theo coin
            if (buyButtons != null && i < buyButtons.Length && buyButtons[i] != null)
            {
                bool canAfford = EconomyManager.I ? (EconomyManager.I.Coin >= price) : true;
                buyButtons[i].interactable = canAfford;
            }
        }
    }

    void TrySubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged += _ => RefreshAll();
    }
    void TryUnsubscribeCoinEvent()
    {
        if (EconomyManager.I == null) return;
        EconomyManager.I.OnCoinChanged -= _ => RefreshAll(); // kh√¥ng h·∫°i n·∫øu kh√¥ng tr√πng delegate
    }
}
# ---- END ----

# ==== FILE 20/31: Scripts\UI\HUDCoinBinder.cs
# SIZE: 659 bytes | LINES: 28
# ---- BEGIN ----
using TMPro;
using UnityEngine;

public class HUDCoinBinder : MonoBehaviour
{
    [SerializeField] private TMP_Text coinText;

    private void Start()
    {
        if (coinText == null)
            coinText = GetComponentInChildren<TMP_Text>();

        // init from save
        coinText.text = $"Coin: {EconomyManager.I.Coin}";
        EconomyManager.I.OnCoinChanged += OnCoinChanged;
    }

    private void OnDestroy()
    {
        if (EconomyManager.I != null)
            EconomyManager.I.OnCoinChanged -= OnCoinChanged;
    }

    private void OnCoinChanged(long value)
    {
        coinText.text = $"{value}" ;
    }
}
# ---- END ----

# ==== FILE 21/31: Scripts\UI\ResultPanelController.cs
# SIZE: 1202 bytes | LINES: 49
# ---- BEGIN ----
// Assets/Scripts/UI/ResultPanelController.cs
using TMPro;
using UnityEngine;

public class ResultPanelController : MonoBehaviour
{
    public WaveManager wm;
    public GameObject root;
    public TMP_Text title;
    public TMP_Text waveText;

    void Start()
    {
        if (root) root.SetActive(false);
        if (wm)
        {
            wm.OnWin += ShowWin;
            wm.OnFail += ShowFail;
        }
    }
    void OnDestroy()
    {
        if (wm)
        {
            wm.OnWin -= ShowWin;
            wm.OnFail -= ShowFail;
        }
    }

    void ShowWin()
    {
        if (!root) return;
        root.SetActive(true);
        if (title) title.text = "WIN!";
        if (waveText) waveText.text = $"Wave {wm.CurrentWave - 1} cleared";
    }

    void ShowFail()
    {
        if (!root) return;
        root.SetActive(true);
        if (title) title.text = "FAIL!";
        if (waveText) waveText.text = $"Failed at Wave {wm.CurrentWave}";
    }

    // Hook UI buttons
    public void OnClaim() { wm.ClaimAndContinue(); if (root) root.SetActive(false); }
    public void OnRetry() { wm.Retry(); if (root) root.SetActive(false); }
}
# ---- END ----

# ==== FILE 22/31: Scripts\UI\StartMenuController.cs
# SIZE: 529 bytes | LINES: 26
# ---- BEGIN ----
using UnityEngine;
using UnityEngine.Audio;
using UnityEngine.SceneManagement;

public class StartMenuController : MonoBehaviour
{
    public AudioMixer audioMixer;

    public void OnStartClick()
    {
        SceneManager.LoadScene("Game");
    }

    public void OnExitClick()
    {
#if UNITY_EDITOR
        UnityEditor.EditorApplication.isPlaying = false;
#endif
        Application.Quit();
    }

    public void SetVolume(float volume)
    {
        audioMixer.SetFloat("Volume", volume);
    }
}
# ---- END ----

# ==== FILE 23/31: Scripts\Upgrades\UpgradeDefinitionSO.cs
# SIZE: 829 bytes | LINES: 24
# ---- BEGIN ----
using UnityEngine;
public enum UpgradeKind { Team, PerType }

[CreateAssetMenu(menuName = "CR/Upgrades/Definition")]
public class UpgradeDefinitionSO : ScriptableObject
{
    [Header("Meta")]
    public string id;
    public string displayName;
    public UpgradeKind kind;
    public ChickenType typeTarget; // d√πng n·∫øu PerType

    [Header("Economy")]
    public long baseCost = 2000;
    public float growth = 1.22f; // team dmg/as 1.22; mps 1.30; per-type 1.25

    [Header("Effect per level")]
    public float teamDamagePct = 0.08f; // 8%/lv
    public float teamASPct = 0.06f; // 6%/lv
    public float eggSeconds = 0.2f;  // 0.2s/lv
    public long mpsValue = 2;     // 2 coin/s/lv
    public float discountPct = 0.03f; // 3%/lv (cap 50%)
    public float perTypeDpsPct = 0.10f; // 10%/lv
}
# ---- END ----

# ==== FILE 24/31: Scripts\Upgrades\UpgradeIds.cs
# SIZE: 524 bytes | LINES: 12
# ---- BEGIN ----
public static class UpgradeIds
{
    // Team
    public const string Team_Damage = "team_damage";       // +8%/lv
    public const string Team_AS = "team_attack_speed"; // +6%/lv
    public const string Team_EggSpeed = "team_egg_speed";    // -0.2s/lv
    public const string Team_MPS = "team_mps";          // +2 coin/s/lv
    public const string Team_Discount = "team_discount";     // -3%/lv (cap 50%)

    // Per-type
    public static string TypeKey(ChickenType t) => $"type_{t.ToString().ToLower()}";
}
# ---- END ----

# ==== FILE 25/31: Scripts\Upgrades\UpgradeManager.cs
# SIZE: 7348 bytes | LINES: 209
# ---- BEGIN ----
// Assets/Scripts/Upgrades/UpgradeManager.cs
// Sprint 4 - Upgrade core (Team + Per-Type)
// - Qu·∫£n l√Ω level, gi√° n√¢ng c·∫•p, v√† xu·∫•t c√°c multiplier/effect ƒë·ªÉ h·ªá th·ªëng kh√°c d√πng.
// - Ph·ª• thu·ªôc: SaveManager (Data.teamUpgrades/typeUpgrades), EconomyManager (TrySpend),
//              UpgradeDefinitionSO[], UpgradeIds, ChickenType.
//
// H∆Ø·ªöNG D·∫™N INSPECTOR:
//   - G·∫Øn script n√†y l√™n 1 GameObject t·ªìn t·∫°i su·ªët game (v√≠ d·ª• _Systems).
//   - K√©o T·∫§T C·∫¢ c√°c asset UpgradeDefinitionSO v√†o m·∫£ng 'upgradeDefs'.
//   - Team IDs d√πng: team_damage, team_attack_speed, team_egg_speed, team_mps, team_discount
//   - Per-type IDs d√πng: type_soldier, type_rapid, type_sniper, type_shotgun, type_rocket, type_support
//
// API CH√çNH:
//   int   GetLevel(string id)
//   long  GetPriceNext(string id)         // baseCost * growth^level
//   bool  TryBuy(string id)               // tr·ª´ coin & tƒÉng level
//
//   float TeamDamageMul()  // (1 + 0.08)^lv
//   float TeamASMul()      // (1 + 0.06)^lv
//   float TeamDiscountFrac() // lv*0.03 (√°p cap 50% khi T√çNH GI√Å G√Ä, th·ª±c hi·ªán ·ªü ShopManager)
//   float TeamEggSeconds() // lv*0.2s  (d√πng gi·∫£m th·ªùi gian t·∫£i tr·ª©ng)
//   long  TeamMPS()        // lv*2 coin/s
//   float PerTypeMul(ChickenType t) // (1+0.10)^lv theo t·ª´ng lo·∫°i g√†
//
// G·ª¢I √ù HOOK:
//   - Damage m·ªói vi√™n = baseDamage * TeamDamageMul() * PerTypeMul(type) * critMul
//   - ROF hi·ªáu d·ª•ng   = baseROF * TeamASMul()
//   - Ticker MPS: m·ªói gi√¢y EconomyManager.I.AddCoin(TeamMPS());

using System;
using System.Collections.Generic;
using UnityEngine;

public class UpgradeManager : MonoBehaviour
{
    public static UpgradeManager I { get; private set; }

    [Header("Database")]
    [Tooltip("K√©o t·∫•t c·∫£ UpgradeDefinitionSO (team + per-type) v√†o ƒë√¢y")]
    public UpgradeDefinitionSO[] upgradeDefs;

    // Tra c·ª©u nhanh theo id
    private Dictionary<string, UpgradeDefinitionSO> _byId;

    // ========================================
    // Unity lifecycle
    // ========================================
    private void Awake()
    {
        if (I != null && I != this) { Destroy(gameObject); return; }
        I = this;
        DontDestroyOnLoad(gameObject);

        // Build index
        _byId = new Dictionary<string, UpgradeDefinitionSO>(StringComparer.Ordinal);
        if (upgradeDefs != null)
        {
            foreach (var d in upgradeDefs)
            {
                if (d == null || string.IsNullOrEmpty(d.id)) continue;
                _byId[d.id] = d;
            }
        }

        // Ensure save maps
        if (SaveManager.Data.teamUpgrades == null) SaveManager.Data.teamUpgrades = new Dictionary<string, int>();
        if (SaveManager.Data.typeUpgrades == null) SaveManager.Data.typeUpgrades = new Dictionary<string, int>();
    }

    // ========================================
    // Level: get/set + persist
    // ========================================
    public int GetLevel(string id)
    {
        if (string.IsNullOrEmpty(id) || !_byId.ContainsKey(id)) return 0;

        var def = _byId[id];
        if (def.kind == UpgradeKind.Team)
        {
            return SaveManager.Data.teamUpgrades.TryGetValue(id, out var lv) ? lv : 0;
        }
        else // PerType
        {
            return SaveManager.Data.typeUpgrades.TryGetValue(id, out var lv) ? lv : 0;
        }
    }

    private void SetLevel(string id, int level)
    {
        if (string.IsNullOrEmpty(id) || !_byId.ContainsKey(id)) return;

        level = Mathf.Max(0, level);
        var def = _byId[id];

        if (def.kind == UpgradeKind.Team)
        {
            SaveManager.Data.teamUpgrades[id] = level;
        }
        else
        {
            SaveManager.Data.typeUpgrades[id] = level;
        }
        Persist();
    }

    private static void Persist()
    {
        // D√πng SaveManager.Save() ƒë·ªÉ t∆∞∆°ng th√≠ch m√£ s·∫µn c√≥ c·ªßa b·∫°n
        SaveManager.Save();
    }

    // ========================================
    // Gi√° n√¢ng c·∫•p & mua
    // ========================================
    public long GetPriceNext(string id)
    {
        if (string.IsNullOrEmpty(id) || !_byId.TryGetValue(id, out var def)) return long.MaxValue;

        int lv = GetLevel(id);
        double cost = def.baseCost * Math.Pow(def.growth, lv);
        if (cost < 1d) cost = 1d;
        return (long)Math.Round(cost);
    }

    public bool TryBuy(string id)
    {
        long price = GetPriceNext(id);
        if (!EconomyManager.I.TrySpend(price)) return false;

        SetLevel(id, GetLevel(id) + 1);
        return true;
    }

    // ========================================
    // Query: Team multipliers/effects
    // ========================================
    public float TeamDamageMul()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_Damage, out var d)) return 1f;
        int lv = GetLevel(d.id);
        return Mathf.Pow(1f + d.teamDamagePct, lv);
    }

    public float TeamASMul()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_AS, out var d)) return 1f;
        int lv = GetLevel(d.id);
        return Mathf.Pow(1f + d.teamASPct, lv);
    }

    /// <summary>
    /// T·ªïng ph·∫ßn trƒÉm gi·∫£m gi√° (0..1). Khi t√≠nh gi√° g√† nh·ªõ √°p CAP 50% (min v·ªõi 0.5f).
    /// </summary>
    public float TeamDiscountFrac()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_Discount, out var d)) return 0f;
        int lv = GetLevel(d.id);
        float total = lv * d.discountPct; // vd 3%/lv
        return Mathf.Max(0f, total);
    }

    /// <summary>
    /// T·ªïng s·ªë gi√¢y gi·∫£m v√†o th·ªùi gian n·∫°p tr·ª©ng (Egg Load). Tu·ª≥ n∆°i d√πng.
    /// </summary>
    public float TeamEggSeconds()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_EggSpeed, out var d)) return 0f;
        int lv = GetLevel(d.id);
        return lv * d.eggSeconds;
    }

    /// <summary>
    /// T·ªïng coin/s c·ªông th√™m.
    /// </summary>
    public long TeamMPS()
    {
        if (!_byId.TryGetValue(UpgradeIds.Team_MPS, out var d)) return 0;
        int lv = GetLevel(d.id);
        long v = lv * d.mpsValue;
        return v < 0 ? 0 : v;
    }

    // ========================================
    // Query: Per-type multiplier
    // ========================================
    public float PerTypeMul(ChickenType type)
    {
        string id = UpgradeIds.TypeKey(type);
        if (!_byId.TryGetValue(id, out var d)) return 1f;
        int lv = GetLevel(id);
        return Mathf.Pow(1f + d.perTypeDpsPct, lv);
    }

    // ========================================
    // Ti·ªán √≠ch (t√πy ch·ªçn): ki·ªÉm tra asset/ID
    // ========================================
#if UNITY_EDITOR
    [ContextMenu("Validate Upgrade IDs in Console")]
    private void ValidateInConsole()
    {
        foreach (var kv in _byId)
        {
            var d = kv.Value;
            string extra = d.kind == UpgradeKind.PerType ? $" (PerType:{d.typeTarget})" : " (Team)";
            Debug.Log($"[UpgradeDef] id={d.id} base={d.baseCost} growth={d.growth}{extra}");
        }
    }
#endif
}
# ---- END ----

# ==== FILE 26/31: Scripts\Wave\EnemyHook.cs
# SIZE: 413 bytes | LINES: 17
# ---- BEGIN ----
// Assets/Scripts/Wave/EnemyHook.cs
using UnityEngine;

// G·∫Øn v√†o prefab Enemy ƒë·ªÉ WaveManager bi·∫øt khi n√†o ƒë√£ clear h·∫øt
[RequireComponent(typeof(Enemy))]
public class EnemyHook : MonoBehaviour
{
    void OnEnable()
    {
        if (EnemyRegistry.I) EnemyRegistry.I.Register();
    }

    void OnDisable()
    {
        if (EnemyRegistry.I) EnemyRegistry.I.Unregister();
    }
}
# ---- END ----

# ==== FILE 27/31: Scripts\Wave\EnemyRegistry.cs
# SIZE: 841 bytes | LINES: 37
# ---- BEGIN ----
using System;
using UnityEngine;

public class EnemyRegistry : MonoBehaviour
{
    // Singleton ƒë·ªÉ WaveManager g·ªçi nhanh
    public static EnemyRegistry I { get; private set; }

    public event Action OnAllCleared;

    private int _alive = 0;

    void Awake()
    {
        if (I != null && I != this)
        {
            Destroy(gameObject);
            return;
        }
        I = this;
    }

    /// <summary>G·ªçi khi Enemy spawn (EnemyHook.OnEnable)</summary>
    public void Register()
    {
        _alive++;
    }

    /// <summary>G·ªçi khi Enemy ch·∫øt ho·∫∑c b·ªã disable (EnemyHook.OnDisable)</summary>
    public void Unregister()
    {
        _alive = Mathf.Max(0, _alive - 1);
        if (_alive == 0) OnAllCleared?.Invoke();
    }

    public int AliveCount => _alive;
}
# ---- END ----

# ==== FILE 28/31: Scripts\Wave\WaveDefinitionSO.cs
# SIZE: 1173 bytes | LINES: 37
# ---- BEGIN ----
using System;
using UnityEngine;

namespace CR.Wave
{
    public enum LaneMode { FixedY, RandomFromList, RandomRangeY }

    [CreateAssetMenu(menuName = "CR/Wave", fileName = "Wave_")]
    public class WaveDefinitionSO : ScriptableObject
    {
        public int waveIndex;
        public float targetDuration = 25f;
        public bool isBoss;

        [Serializable]
        public struct Group
        {
            public EnemyDefinitionSO enemy;
            [Min(1)] public int count;
            [Min(0.01f)] public float interval;
            [Min(0f)] public float startTime;

            [Header("Lane Y")]
            public LaneMode laneMode;       // NEW
            public float laneY;             // d√πng cho FixedY
            public float[] laneList;        // d√πng khi RandomFromList
            public Vector2 yRange;          // d√πng khi RandomRangeY
            // Gi·ªØ spawnX c≈©, KH√îNG random
            public float spawnX;

            [Header("Timing")]
            public Vector2 intervalJitterPct; // ¬±% jitter (tu·ª≥ ch·ªçn)
        }

        public Group[] groups = Array.Empty<Group>();
    }
}
# ---- END ----

# ==== FILE 29/31: Scripts\Wave\WaveManager.cs
# SIZE: 4601 bytes | LINES: 137
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveManager.cs
using CR.Wave;
using System;
using UnityEngine;

public class WaveManager : MonoBehaviour
{
    [Header("Refs")]
    public BaseHealth baseHealth;
    public WaveSpawner spawner;
    public ProgressionCurveSO progression; // ƒë·ªÉ t√≠nh th∆∞·ªüng c∆° b·∫£n :contentReference[oaicite:7]{index=7}

    [Header("Definitions")]
    public WaveDefinitionSO[] presets; // Wave 1-20 c√≥ th·ªÉ preset tay
    public bool autoStart = true;

    [Header("Runtime (read-only)")]
    [SerializeField] private WaveState state = WaveState.Prepare;
    [SerializeField] private int currentWaveIndex;
    [SerializeField] private bool lastWin;

    public event Action OnWin;
    public event Action OnFail;

    void Awake()
    {
        // Kh·ªüi ƒë·ªông t·ª´ Save
        currentWaveIndex = Mathf.Max(1, SaveManager.Data.waveIndex + 1);
    }

    void OnEnable()
    {
        if (baseHealth) baseHealth.OnBaseDead += HandleBaseDead;
        if (EnemyRegistry.I) EnemyRegistry.I.OnAllCleared += HandleAllCleared; // win khi h·∫øt enemy :contentReference[oaicite:8]{index=8}
    }

    void OnDisable()
    {
        if (baseHealth) baseHealth.OnBaseDead -= HandleBaseDead;
        if (EnemyRegistry.I) EnemyRegistry.I.OnAllCleared -= HandleAllCleared;
    }

    void Start()
    {
        if (autoStart || SaveManager.Data.autoStart) GoPrepare();
    }

    public void GoPrepare()
    {
        state = WaveState.Prepare;
        lastWin = false;
        // T·∫°i Prepare b·∫°n c√≥ th·ªÉ m·ªü UI n√¢ng c·∫•p/mua g√†...
        if (autoStart || SaveManager.Data.autoStart) StartCombat();
    }

    public void StartCombat()
    {
        if (state != WaveState.Prepare) return;
        state = WaveState.Combat;

        // L·∫•y wave def (∆∞u ti√™n preset)
        var def = GetWaveDefinition(currentWaveIndex);
        if (!def) { Debug.LogWarning($"[WaveManager] Missing Wave {currentWaveIndex} def"); }
        spawner.Begin(def);

        // Reset/scale Base HP theo wave ƒë√£ c√≥ trong BaseHealth (ƒëang t√≠nh b·∫±ng base + hpPerWave*wave) :contentReference[oaicite:9]{index=9}
    }

    WaveDefinitionSO GetWaveDefinition(int waveIndex)
    {
        // 1‚Äì20: d√πng preset n·∫øu c√≥
        if (presets != null && waveIndex - 1 < presets.Length && waveIndex - 1 >= 0)
            return presets[waveIndex - 1];

        // ‚â•21: v·ªÅ sau g·∫Øn RuntimeWaveGenerator (Sprint 6)
        return presets != null && presets.Length > 0 ? presets[Mathf.Clamp(presets.Length - 1, 0, presets.Length - 1)] : null;
    }

    void HandleAllCleared()
    {
        if (state != WaveState.Combat) return;
        if (!spawner.IsFinishedSpawning) return; // ch∆∞a spawn xong m√† h·∫øt l√† do timing, ch·ªù ti·∫øp
        // WIN
        lastWin = true;
        GrantRewards(currentWaveIndex);
        AdvanceWaveIndex();
        state = WaveState.Result;
        OnWin?.Invoke();
        // M·ªü UI Result Win (Claim). Sau Claim ‚Üí GoPrepare();
    }

    void HandleBaseDead()
    {
        if (state != WaveState.Combat) return;
        // FAIL
        lastWin = false;
        // Kh√¥ng c·ªông WaveReward, ch·ªâ gi·ªØ coin r∆°i trong combat (ƒë√£ AddCoin khi enemy ch·∫øt)
        state = WaveState.Result;
        OnFail?.Invoke();
        // UI Result Fail ‚Üí Retry (replay wave) ho·∫∑c Back
    }

    void AdvanceWaveIndex()
    {
        SaveManager.Data.waveIndex = Mathf.Max(SaveManager.Data.waveIndex, currentWaveIndex);
        SaveManager.MarkDirtyAndSave();
        currentWaveIndex = SaveManager.Data.waveIndex + 1;
    }

    void GrantRewards(int waveIndex)
    {
        if (!progression) return;
        // C√¥ng th·ª©c g·ª£i √Ω: WaveReward = 1000 * (waveRewardGrowth^waveIndex)
        double baseReward = 1000.0 * Math.Pow(progression.waveRewardGrowth, waveIndex);
        long reward = (long)Math.Round(baseReward);
        EconomyManager.I.AddCoin(reward); // EconomyManager ƒë√£ c√≥ s·∫µn :contentReference[oaicite:10]{index=10}
    }

    // Public API cho UI
    public WaveState State => state;
    public int CurrentWave => currentWaveIndex;
    public bool LastWin => lastWin;

    public void ClaimAndContinue()
    {
        if (state != WaveState.Result) return;
        GoPrepare();
    }

    public void Retry()
    {
        if (state != WaveState.Result) return;
        // Retry l·∫°i c√πng waveIndex hi·ªán t·∫°i (kh√¥ng advance)
        state = WaveState.Prepare;
        StartCombat();
    }
}
# ---- END ----

# ==== FILE 30/31: Scripts\Wave\WaveSpawner.cs
# SIZE: 4064 bytes | LINES: 132
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveSpawner.cs
using CR.Wave;
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class EnemyPrefabEntry
{
    public EnemyDefinitionSO definition;   // SO c·ªßa lo·∫°i enemy
    public Enemy prefab;                   // Prefab t∆∞∆°ng ·ª©ng
}

public class WaveSpawner : MonoBehaviour
{
    [Header("Mapping SO ‚Üí Prefab")]
    public EnemyPrefabEntry[] enemyPrefabs;   // K√©o th·∫£ trong Inspector

    [Header("Refs")]
    public Transform poolRoot;                // Container t√πy ch·ªçn
    public BaseHealth baseHealth;             // Base ƒë·ªÉ qu√°i t√¨m ƒë·∫øn

    [Header("Runtime")]
    public WaveDefinitionSO wave;

    // N·ªôi b·ªô
    Dictionary<EnemyDefinitionSO, ObjectPool<Enemy>> _pools;
    Dictionary<EnemyDefinitionSO, Enemy> _prefabByDef;
    float _t;
    int[] _spawnedPerGroup;
    bool _active;

    void Awake()
    {
        _pools = new Dictionary<EnemyDefinitionSO, ObjectPool<Enemy>>();
        _prefabByDef = new Dictionary<EnemyDefinitionSO, Enemy>();

        if (enemyPrefabs == null) return;

        foreach (var entry in enemyPrefabs)
        {
            // ‚úÖ d√πng so s√°nh null, KH√îNG d√πng !
            if (entry == null || entry.definition == null || entry.prefab == null)
                continue;

            _prefabByDef[entry.definition] = entry.prefab;
            _pools[entry.definition] = new ObjectPool<Enemy>(entry.prefab, poolRoot);
        }
    }

    public void Begin(WaveDefinitionSO def)
    {
        wave = def;
        _t = 0f;
        _active = true;
        _spawnedPerGroup = wave != null && wave.groups != null ? new int[wave.groups.Length] : null;
    }

    public bool IsFinishedSpawning
    {
        get
        {
            if (wave == null || _spawnedPerGroup == null) return true;
            for (int i = 0; i < _spawnedPerGroup.Length; i++)
                if (_spawnedPerGroup[i] < wave.groups[i].count) return false;
            return true;
        }
    }

    void Update()
    {
        if (!_active || wave == null) return;
        _t += Time.deltaTime;

        for (int i = 0; i < wave.groups.Length; i++)
        {
            var g = wave.groups[i];
            if (_t < g.startTime) continue;

            if (_spawnedPerGroup[i] < g.count)
            {
                int expect = Mathf.FloorToInt((_t - g.startTime) / Mathf.Max(0.01f, g.interval)) + 1;
                int toSpawn = Mathf.Clamp(expect - _spawnedPerGroup[i], 0, g.count - _spawnedPerGroup[i]);
                for (int k = 0; k < toSpawn; k++) SpawnOne(g);
                _spawnedPerGroup[i] += toSpawn;
            }
        }

        if (IsFinishedSpawning) _active = false;
    }

    private void SpawnOne(WaveDefinitionSO.Group g)
    {
        if (!_pools.TryGetValue(g.enemy, out var pool))
        {
            Debug.LogError($"[WaveSpawner] Missing prefab mapping for {g.enemy?.name}");
            return;
        }

        var e = pool.Get();
        e.def = g.enemy;
        e.targetBase = baseHealth;

        float y;
        switch (g.laneMode)
        {
            case LaneMode.RandomFromList:
                var list = g.laneList != null && g.laneList.Length > 0
                           ? g.laneList
                           : new[] { g.laneY };
                y = list[Random.Range(0, list.Length)];
                break;

            case LaneMode.RandomRangeY:
                var yr = g.yRange;
                if (yr.x > yr.y) (yr.x, yr.y) = (yr.y, yr.x);
                y = Random.Range(yr.x, yr.y);
                break;

            default: // FixedY
                y = g.laneY;
                break;
        }

        // Gi·ªØ X c·ªë ƒë·ªãnh (spawnX c·ªßa group)
        float x = g.spawnX;

        e.transform.position = new Vector3(x, y, 0f);

        if (!e.TryGetComponent<EnemyHook>(out _))
            e.gameObject.AddComponent<EnemyHook>();
    }
}
# ---- END ----

# ==== FILE 31/31: Scripts\Wave\WaveState.cs
# SIZE: 108 bytes | LINES: 7
# ---- BEGIN ----
// Assets/Scripts/Wave/WaveState.cs
public enum WaveState
{
    Prepare,
    Combat,
    Result
}
# ---- END ----

========== SUMMARY ==========
31 file(s), 1724 lines, 53655 bytes
